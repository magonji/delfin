<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delfin - Tools</title>
    <link rel="icon" href="favicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .tool-card {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        .tool-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }
        
        .tool-title {
            font-size: 20px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        
        .tool-description {
            font-size: 14px;
            color: #666;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 3% auto;
            padding: 30px;
            border-radius: 15px;
            width: 90%;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .modal-header {
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .modal-header h3 {
            margin: 0;
            color: #333;
        }
        
        .close-btn {
            font-size: 28px;
            font-weight: bold;
            color: #999;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            width: auto;
        }
        
        .close-btn:hover {
            color: #333;
            transform: none;
        }
        
        .item-list {
            max-height: 400px;
            overflow-y: auto;
        }
        
        .item-row {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 10px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        .item-info {
            flex: 1;
        }
        
        .item-name {
            font-weight: 600;
            color: #333;
            font-size: 16px;
        }
        
        .item-meta {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
        }
        
        .item-actions {
            display: flex;
            gap: 5px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button.secondary {
            background: #6c757d;
        }
        
        button.danger {
            background: #ef4444;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }
        
        input, select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .success-message {
            background: #10b981;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        
        .error-message {
            background: #ef4444;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
        }
        
        .search-box {
            margin-bottom: 20px;
        }

        #transactionsTable input, #transactionsTable select {
            padding: 6px;
            font-size: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
        }

        #transactionsTable tbody tr {
            border-bottom: 1px solid #e0e0e0;
        }

        #transactionsTable tbody tr:hover {
            background: #f8f9fa;
        }

        #transactionsTable tbody tr.duplicate {
            background: #fee;
            opacity: 0.6;
        }
    </style>
    <script src="navbar.js"></script>
</head>
<body>
    <div class="container">
        <div id="successMessage" class="success-message"></div>
        <div id="errorMessage" class="error-message"></div>
        
        <div class="tools-grid">
            <div class="tool-card" onclick="openTool('categories')">
                <div class="tool-icon">üìÅ</div>
                <div class="tool-title">Manage Categories</div>
                <div class="tool-description">Edit parent categories and subcategories</div>
            </div>
            
            <div class="tool-card" onclick="openTool('accounts')">
                <div class="tool-icon">üí≥</div>
                <div class="tool-title">Manage Accounts</div>
                <div class="tool-description">Edit account names and currencies</div>
            </div>
            
            <div class="tool-card" onclick="openTool('payees')">
                <div class="tool-icon">üë§</div>
                <div class="tool-title">Manage Payees</div>
                <div class="tool-description">Edit payee names</div>
            </div>
            
            <div class="tool-card" onclick="openTool('locations')">
                <div class="tool-icon">üìç</div>
                <div class="tool-title">Manage Locations</div>
                <div class="tool-description">Edit location names</div>
            </div>
            
            <div class="tool-card" onclick="openTool('projects')">
                <div class="tool-icon">üìã</div>
                <div class="tool-title">Manage Projects</div>
                <div class="tool-description">Edit project names</div>
            </div>

            <div class="tool-card" onclick="openTool('import')">
                <div class="tool-icon">üì•</div>
                <div class="tool-title">Import Bank Statements</div>
                <div class="tool-description">Import transactions from CSV bank statements</div>
            </div>
            <div class="tool-card" onclick="openTool('export')">
                <div class="tool-icon">üì§</div>
                <div class="tool-title">Export to CSV</div>
                <div class="tool-description">Export your transactions to CSV format</div>
            </div>
            
            <div class="tool-card" onclick="openTool('backup')">
                <div class="tool-icon">üíæ</div>
                <div class="tool-title">Backup Database</div>
                <div class="tool-description">Download a backup of your database with timestamp</div>
            </div>
        </div>
    </div>
    
    <!-- Categories Modal -->
    <div id="categoriesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Manage Categories</h3>
                <button class="close-btn" onclick="closeModal('categoriesModal')">&times;</button>
            </div>
            <div class="search-box">
                <input type="text" id="categorySearch" placeholder="Search categories..." onkeyup="filterCategories()">
            </div>
            <div class="item-list" id="categoriesList"></div>
        </div>
    </div>
    
    <!-- Accounts Modal -->
    <div id="accountsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Manage Accounts</h3>
                <button class="close-btn" onclick="closeModal('accountsModal')">&times;</button>
            </div>
            <div class="search-box">
                <input type="text" id="accountSearch" placeholder="Search accounts..." onkeyup="filterAccounts()">
            </div>
            <div class="item-list" id="accountsList"></div>
        </div>
    </div>
    
    <!-- Payees Modal -->
    <div id="payeesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Manage Payees</h3>
                <button class="close-btn" onclick="closeModal('payeesModal')">&times;</button>
            </div>
            <div class="search-box">
                <input type="text" id="payeeSearch" placeholder="Search payees..." onkeyup="filterPayees()">
            </div>
            <div class="item-list" id="payeesList"></div>
        </div>
    </div>
    
    <!-- Locations Modal -->
    <div id="locationsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Manage Locations</h3>
                <button class="close-btn" onclick="closeModal('locationsModal')">&times;</button>
            </div>
            <div class="search-box">
                <input type="text" id="locationSearch" placeholder="Search locations..." onkeyup="filterLocations()">
            </div>
            <div class="item-list" id="locationsList"></div>
        </div>
    </div>
    
    <!-- Projects Modal -->
    <div id="projectsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>Manage Projects</h3>
                <button class="close-btn" onclick="closeModal('projectsModal')">&times;</button>
            </div>
            <div class="search-box">
                <input type="text" id="projectSearch" placeholder="Search projects..." onkeyup="filterProjects()">
            </div>
            <div class="item-list" id="projectsList"></div>
        </div>
    </div>
    
    <!-- Edit Modal -->
    <div id="editModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3 id="editModalTitle">Edit Item</h3>
                <button class="close-btn" onclick="closeModal('editModal')">&times;</button>
            </div>
            <div class="form-group">
                <label for="editName">Name</label>
                <input type="text" id="editName">
            </div>
            <div class="form-group" id="editCurrencyGroup" style="display: none;">
                <label for="editCurrency">Currency</label>
                <select id="editCurrency">
                    <option value="GBP">GBP (¬£)</option>
                    <option value="EUR">EUR (‚Ç¨)</option>
                    <option value="USD">USD ($)</option>
                </select>
            </div>
            <div class="form-group" id="editParentGroup" style="display: none;">
                <label for="editParent">Parent Category</label>
                <input type="text" id="editParent" readonly style="background: #f0f0f0;">
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="saveEdit()" style="flex: 1;">Save</button>
                <button onclick="closeModal('editModal')" class="secondary" style="flex: 1;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="importModal" class="modal">
        <div class="modal-content" style="max-width: 95%; max-height: 90vh;">
            <div class="modal-header">
                <h3>üì• Import Bank Statements</h3>
                <button class="close-btn" onclick="closeModal('importModal')">&times;</button>
            </div>
            
            <div id="uploadSection">
                <div style="border: 2px dashed #667eea; border-radius: 10px; padding: 40px; text-align: center; margin-bottom: 20px; background: #f8f9ff;">
                    <div style="font-size: 48px; margin-bottom: 15px;">üìÑ</div>
                    <h4 style="margin-bottom: 10px; color: #333;">Upload your bank statement</h4>
                    <p style="color: #666; margin-bottom: 20px;">Supported format: CSV</p>
                    <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileUpload(event)">
                    <button onclick="document.getElementById('fileInput').click()" style="padding: 12px 30px;">Choose File</button>
                </div>
                
                <div class="form-group">
                    <label for="importAccount">Select Account for Import</label>
                    <select id="importAccount" required>
                        <option value="">Select account...</option>
                    </select>
                </div>
            </div>
            
            <div id="previewSection" style="display: none;">
                <div style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <h4 style="margin-bottom: 10px;">Preview Transactions</h4>
                    <p style="color: #666; font-size: 14px;">Review and map transactions before importing. Select payees to auto-fill categories. Mark transfers to link with other accounts.</p>
                    <div style="margin-top: 10px;">
                        <span style="font-weight: 600;">Total transactions:</span> <span id="totalTransactions">0</span> | 
                        <span style="font-weight: 600;">Duplicates found:</span> <span id="duplicateCount" style="color: #ef4444;">0</span> | 
                        <span style="font-weight: 600;">New transactions:</span> <span id="newCount" style="color: #10b981;">0</span>
                    </div>
                </div>
                
                <div style="overflow-x: auto; max-height: 500px; overflow-y: auto;">
                    <table id="transactionsTable" style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead style="position: sticky; top: 0; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                            <tr style="background: #667eea; color: white;">
                                <th style="padding: 10px; text-align: center; width: 50px;">Skip</th>
                                <th style="padding: 10px; text-align: left;">Date/Time</th>
                                <th style="padding: 10px; text-align: left;">Description</th>
                                <th style="padding: 10px; text-align: right;">Amount</th>
                                <th style="padding: 10px; text-align: center; min-width: 120px;">Type</th>
                                <th style="padding: 10px; text-align: left; min-width: 150px;">Payee / To Account</th>
                                <th style="padding: 10px; text-align: left; min-width: 150px;">Category</th>
                                <th style="padding: 10px; text-align: left;">Location</th>
                                <th style="padding: 10px; text-align: left;">Project</th>
                                <th style="padding: 10px; text-align: left; min-width: 200px;">Note</th>
                                <th style="padding: 10px; text-align: center;">Status</th>
                            </tr>
                        </thead>
                        <tbody id="transactionsTableBody">
                            <!-- Rows will be inserted here -->
                        </tbody>
                    </table>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button onclick="importTransactions()" style="flex: 1; padding: 15px; font-size: 16px;">‚úÖ Import <span id="importCount">0</span> Transactions</button>
                    <button onclick="cancelImport()" class="secondary" style="flex: 0 0 auto; padding: 15px 30px;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="exportModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <h3>üì§ Export to CSV</h3>
                <button class="close-btn" onclick="closeModal('exportModal')">&times;</button>
            </div>
            
            <div style="background: #f0f4ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <p style="color: #666; font-size: 14px;">Select filters to export specific transactions, or leave empty to export all.</p>
            </div>
            
            <div class="form-group">
                <label for="exportStartDate">From Date</label>
                <input type="date" id="exportStartDate">
            </div>
            
            <div class="form-group">
                <label for="exportEndDate">To Date</label>
                <input type="date" id="exportEndDate">
            </div>
            
            <div class="form-group">
                <label for="exportAccount">Account</label>
                <select id="exportAccount">
                    <option value="">All accounts</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="exportParentCategory">Parent Category</label>
                <select id="exportParentCategory" onchange="loadExportSubcategories()">
                    <option value="">All categories</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="exportCategory">Subcategory</label>
                <select id="exportCategory" disabled>
                    <option value="">First select a parent category...</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="exportFormat">CSV Format</label>
                <select id="exportFormat">
                    <option value="standard">Standard Format</option>
                    <option value="detailed">Detailed Format (with all fields)</option>
                </select>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button onclick="exportToCSV()" style="flex: 1; padding: 15px;">üì• Download CSV</button>
                <button onclick="closeModal('exportModal')" class="secondary" style="flex: 0 0 auto; padding: 15px 30px;">Cancel</button>
            </div>
        </div>
    </div>
    
    <script>
        const API_URL = 'http://localhost:8000';
        
        let allCategories = [];
        let allAccounts = [];
        let allPayees = [];
        let allLocations = [];
        let allProjects = [];
        
        let currentEditItem = null;
        let currentEditType = null;

        // Import variables
        let parsedTransactions = [];
        let existingTransactions = [];
        let payeeSuggestions = {};
        let allAccountsForImport = [];
                
        // Open tool modal
        async function openTool(toolName) {
            switch(toolName) {
                case 'categories':
                    await loadCategories();
                    displayCategories();
                    document.getElementById('categoriesModal').style.display = 'block';
                    break;
                case 'accounts':
                    await loadAccounts();
                    displayAccounts();
                    document.getElementById('accountsModal').style.display = 'block';
                    break;
                case 'payees':
                    await loadPayees();
                    displayPayees();
                    document.getElementById('payeesModal').style.display = 'block';
                    break;
                case 'locations':
                    await loadLocations();
                    displayLocations();
                    document.getElementById('locationsModal').style.display = 'block';
                    break;
                case 'projects':
                    await loadProjects();
                    displayProjects();
                    document.getElementById('projectsModal').style.display = 'block';
                    break;
                case 'import':
                    await loadImportData();
                    document.getElementById('importModal').style.display = 'block';
                    break;
                case 'export':
                    await loadExportData();
                    document.getElementById('exportModal').style.display = 'block';
                    break;
                case 'backup':
                    document.getElementById('backupModal').style.display = 'block';
                    document.getElementById('backupStatus').style.display = 'none';
                    break;
            }
        }
   
        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        // Load data functions
        async function loadCategories() {
            const response = await fetch(`${API_URL}/categories?limit=1000`);
            allCategories = await response.json();
            
            // Sort alphabetically by parent first, then by name
            allCategories.sort((a, b) => {
                const parentA = a.parent || '';
                const parentB = b.parent || '';
                if (parentA !== parentB) {
                    return parentA.localeCompare(parentB);
                }
                return a.name.localeCompare(b.name);
            });
        }
        
        async function loadAccounts() {
            const response = await fetch(`${API_URL}/accounts`);
            allAccounts = await response.json();
            
            // Sort alphabetically by name
            allAccounts.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        async function loadPayees() {
            const response = await fetch(`${API_URL}/payees`);
            allPayees = await response.json();
            
            // Sort alphabetically by name
            allPayees.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        async function loadLocations() {
            const response = await fetch(`${API_URL}/locations`);
            allLocations = await response.json();
            
            // Sort alphabetically by name
            allLocations.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        async function loadProjects() {
            const response = await fetch(`${API_URL}/projects`);
            allProjects = await response.json();
            
            // Sort alphabetically by name
            allProjects.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        // Display functions
        function displayCategories(filtered = null) {
            const categories = filtered || allCategories;
            const list = document.getElementById('categoriesList');
            
            // Group categories by parent
            const grouped = {};
            const allParentNames = new Set();
            
            categories.forEach(cat => {
                if (cat.parent) {
                    allParentNames.add(cat.parent);
                    if (!grouped[cat.parent]) {
                        grouped[cat.parent] = [];
                    }
                    grouped[cat.parent].push(cat);
                }
            });
            
            // Find standalone parent categories (parents without children)
            const standaloneParents = categories.filter(cat => 
                !cat.parent && !allParentNames.has(cat.name)
            );
            
            // Add standalone parents to grouped (with empty array)
            standaloneParents.forEach(cat => {
                grouped[cat.name] = [];
            });
            
            // Sort all parent names alphabetically
            const sortedParents = Object.keys(grouped).sort((a, b) => a.localeCompare(b));
            
            // Build HTML
            let html = '';
            
            sortedParents.forEach(parent => {
                const subcategories = grouped[parent].sort((a, b) => a.name.localeCompare(b.name));
                
                // Header with parent name and edit button
                if (subcategories.length > 0) {
                    html += `
                        <div style="margin-bottom: 25px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: bold; color: #667eea; margin-bottom: 10px; padding: 10px; background: #f0f4ff; border-radius: 8px;">
                                <span>üìÅ ${parent}</span>
                                <button onclick="editParentCategory('${parent.replace(/'/g, "\\'")}', ${JSON.stringify(subcategories.map(c => c.id))})" style="padding: 6px 12px; font-size: 13px;">‚úèÔ∏è Edit Parent</button>
                            </div>
                    `;
                    
                    subcategories.forEach((cat, index) => {
                        const isLast = index === subcategories.length - 1;
                        const connector = isLast ? '‚îî‚îÄ' : '‚îú‚îÄ';
                        
                        html += `
                            <div class="item-row" style="margin-left: 20px; margin-bottom: 8px;">
                                <div class="item-info">
                                    <div class="item-name">
                                        <span style="color: #999; margin-right: 8px;">${connector}</span>
                                        ${cat.name}
                                    </div>
                                </div>
                                <div class="item-actions">
                                    <button onclick="editItem('category', ${cat.id})">‚úèÔ∏è Edit</button>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                } else {
                    // Standalone parent (no children)
                    const standaloneCategory = standaloneParents.find(c => c.name === parent);
                    html += `
                        <div style="margin-bottom: 25px;">
                            <div class="item-row">
                                <div class="item-info">
                                    <div class="item-name">üìÅ ${parent}</div>
                                    <div class="item-meta">Parent Category (no subcategories)</div>
                                </div>
                                <div class="item-actions">
                                    <button onclick="editItem('category', ${standaloneCategory.id})">‚úèÔ∏è Edit</button>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
            
            if (html === '') {
                html = '<p style="text-align: center; color: #666; padding: 20px;">No categories found</p>';
            }
            
            list.innerHTML = html;
        }
        
        function displayAccounts(filtered = null) {
            const accounts = filtered || allAccounts;
            const list = document.getElementById('accountsList');
            
            list.innerHTML = accounts.map(acc => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${acc.name}</div>
                        <div class="item-meta">Currency: ${acc.currency} | Type: ${acc.type || 'Regular'}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('account', ${acc.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        function displayPayees(filtered = null) {
            const payees = filtered || allPayees;
            const list = document.getElementById('payeesList');
            
            list.innerHTML = payees.map(payee => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${payee.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('payee', ${payee.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        function displayLocations(filtered = null) {
            const locations = filtered || allLocations;
            const list = document.getElementById('locationsList');
            
            list.innerHTML = locations.map(loc => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${loc.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('location', ${loc.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        function displayProjects(filtered = null) {
            const projects = filtered || allProjects;
            const list = document.getElementById('projectsList');
            
            list.innerHTML = projects.map(proj => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${proj.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('project', ${proj.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Filter functions
        function filterCategories() {
            const search = document.getElementById('categorySearch').value.toLowerCase();
            const filtered = allCategories.filter(cat => 
                cat.name.toLowerCase().includes(search) || 
                (cat.parent && cat.parent.toLowerCase().includes(search))
            );
            displayCategories(filtered);
        }
        
        function filterAccounts() {
            const search = document.getElementById('accountSearch').value.toLowerCase();
            const filtered = allAccounts.filter(acc => 
                acc.name.toLowerCase().includes(search)
            );
            displayAccounts(filtered);
        }
        
        function filterPayees() {
            const search = document.getElementById('payeeSearch').value.toLowerCase();
            const filtered = allPayees.filter(payee => 
                payee.name.toLowerCase().includes(search)
            );
            displayPayees(filtered);
        }
        
        function filterLocations() {
            const search = document.getElementById('locationSearch').value.toLowerCase();
            const filtered = allLocations.filter(loc => 
                loc.name.toLowerCase().includes(search)
            );
            displayLocations(filtered);
        }
        
        function filterProjects() {
            const search = document.getElementById('projectSearch').value.toLowerCase();
            const filtered = allProjects.filter(proj => 
                proj.name.toLowerCase().includes(search)
            );
            displayProjects(filtered);
        }
        
        // Edit item
        function editItem(type, id) {
            currentEditType = type;
            let item;
            
            switch(type) {
                case 'category':
                    item = allCategories.find(c => c.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Category';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = item.parent ? 'block' : 'none';
                    if (item.parent) {
                        document.getElementById('editParent').value = item.parent;
                    }
                    break;
                case 'account':
                    item = allAccounts.find(a => a.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Account';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'block';
                    document.getElementById('editCurrency').value = item.currency;
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
                case 'payee':
                    item = allPayees.find(p => p.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Payee';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
                case 'location':
                    item = allLocations.find(l => l.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Location';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
                case 'project':
                    item = allProjects.find(p => p.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Project';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
            }
            
            currentEditItem = item;
            document.getElementById('editModal').style.display = 'block';
        }

        // Edit parent category name
        async function editParentCategory(oldParentName, subcategoryIds) {
            const newParentName = prompt(`Edit parent category name:`, oldParentName);
            
            if (!newParentName || newParentName.trim() === '') {
                return;
            }
            
            if (newParentName.trim() === oldParentName) {
                return; // No change
            }
            
            try {
                // Update all subcategories with the new parent name
                const updatePromises = subcategoryIds.map(async (id) => {
                    const category = allCategories.find(c => c.id === id);
                    
                    const response = await fetch(`${API_URL}/categories/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: category.name,
                            parent: newParentName.trim(),
                            type: category.type
                        })
                    });
                    
                    return response.ok;
                });
                
                const results = await Promise.all(updatePromises);
                
                if (results.every(r => r)) {
                    showSuccess('Parent category renamed successfully!');
                    await loadCategories();
                    displayCategories();
                } else {
                    showError('Some categories failed to update');
                }
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }
        
        // Save edit
        async function saveEdit() {
            const newName = document.getElementById('editName').value.trim();
            
            if (!newName) {
                showError('Name cannot be empty');
                return;
            }
            
            try {
                let endpoint, body;
                
                switch(currentEditType) {
                    case 'category':
                        endpoint = `${API_URL}/categories/${currentEditItem.id}`;
                        body = {
                            name: newName,
                            parent: currentEditItem.parent,
                            type: currentEditItem.type
                        };
                        break;
                    case 'account':
                        endpoint = `${API_URL}/accounts/${currentEditItem.id}`;
                        body = {
                            name: newName,
                            currency: document.getElementById('editCurrency').value,
                            type: currentEditItem.type,
                            initial_balance: currentEditItem.initial_balance
                        };
                        break;
                    case 'payee':
                        endpoint = `${API_URL}/payees/${currentEditItem.id}`;
                        body = { name: newName };
                        break;
                    case 'location':
                        endpoint = `${API_URL}/locations/${currentEditItem.id}`;
                        body = { name: newName };
                        break;
                    case 'project':
                        endpoint = `${API_URL}/projects/${currentEditItem.id}`;
                        body = { name: newName };
                        break;
                }
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                if (response.ok) {
                    showSuccess('Item updated successfully!');
                    closeModal('editModal');
                    
                    // Reload the appropriate list
                    switch(currentEditType) {
                        case 'category':
                            await loadCategories();
                            displayCategories();
                            break;
                        case 'account':
                            await loadAccounts();
                            displayAccounts();
                            break;
                        case 'payee':
                            await loadPayees();
                            displayPayees();
                            break;
                        case 'location':
                            await loadLocations();
                            displayLocations();
                            break;
                        case 'project':
                            await loadProjects();
                            displayProjects();
                            break;
                    }
                } else {
                    showError('Failed to update item');
                }
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }
        
        function showSuccess(message) {
            const element = document.getElementById('successMessage');
            element.textContent = message;
            element.style.display = 'block';
            setTimeout(() => {
                element.style.display = 'none';
            }, 3000);
        }
        
        function showError(message) {
            const element = document.getElementById('errorMessage');
            element.innerHTML = message.replace(/\n/g, '<br>'); // Convert newlines to HTML breaks
            element.style.display = 'block';
            element.style.fontSize = '14px';
            element.style.whiteSpace = 'pre-wrap'; // Preserve formatting
            element.style.maxHeight = '300px';
            element.style.overflowY = 'auto';
            
            setTimeout(() => {
                element.style.display = 'none';
            }, 10000); // Show for 10 seconds instead of 5
        }
        
        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }

        // Load data needed for import
        async function loadImportData() {
            try {
                // Load accounts for import selection
                const accountsResponse = await fetch(`${API_URL}/accounts`);
                allAccountsForImport = await accountsResponse.json();
                
                const importAccountSelect = document.getElementById('importAccount');
                importAccountSelect.innerHTML = '<option value="">Select account...</option>';
                allAccountsForImport.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = `${account.name} (${account.currency})`;
                    importAccountSelect.appendChild(option);
                });
                
                // Load payees
                const payeesResponse = await fetch(`${API_URL}/payees`);
                allPayees = await payeesResponse.json();
                
                // Load categories
                await loadCategories();
                
                // Load locations
                const locationsResponse = await fetch(`${API_URL}/locations`);
                allLocations = await locationsResponse.json();
                
                // Load projects
                const projectsResponse = await fetch(`${API_URL}/projects`);
                allProjects = await projectsResponse.json();
                
                // Load existing transactions for duplicate detection
                const transResponse = await fetch(`${API_URL}/transactions?limit=100000`);
                existingTransactions = await transResponse.json();
                
            } catch (error) {
                console.error('Error loading import data:', error);
                showError('Failed to load data for import');
            }
        }

        // Handle file upload
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const accountId = document.getElementById('importAccount').value;
            if (!accountId) {
                showError('Please select an account first');
                event.target.value = '';
                return;
            }
            
            try {
                if (file.name.toLowerCase().endsWith('.csv')) {
                    await parseCSV(file, accountId);
                } else {
                    showError('Unsupported file format');
                    event.target.value = '';
                    return;
                }
                
                // Show preview section
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('previewSection').style.display = 'block';
                
                displayTransactionsPreview();
                
            } catch (error) {
                console.error('Error processing file:', error);
                // Show detailed error message
                showError('Error processing file: ' + error.message + '\n\nCheck browser console (F12) for more details');
                event.target.value = '';
                
                // Also log the full error to console
                console.error('Full error details:', error);
                console.error('Error stack:', error.stack);
            }
        }

        // Parse CSV file
        async function parseCSV(file, accountId) {
            console.log('Starting CSV parse for file:', file.name);
            
            const text = await file.text();
            console.log('File text length:', text.length);
            
            const lines = text.split('\n');
            console.log('Total lines:', lines.length);
            
            if (lines.length < 2) {
                throw new Error('CSV file is empty or invalid');
            }
            
            // Get headers
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            console.log('Headers found:', headers);
            
            // Detect bank type and parse accordingly
            if (headers.includes('Transaction ID') && headers.includes('Emoji')) {
                console.log('Detected format: Monzo');
                parseMonzoCSV(lines, headers, accountId);
            } else if (headers.some(h => h.toLowerCase().includes('transaction date')) && 
                    headers.some(h => h.toLowerCase().includes('transaction description')) && 
                    headers.some(h => h.toLowerCase().includes('debit amount'))) {
                console.log('Detected format: Bank of Scotland');
                parseBankOfScotlandCSV(lines, headers, accountId);
            } else if (headers.some(h => h.toLowerCase() === 'date') &&
                    headers.some(h => h.toLowerCase() === 'time') &&
                    headers.some(h => h.toLowerCase() === 'gross') &&
                    headers.some(h => h.toLowerCase() === 'fee') &&
                    headers.some(h => h.toLowerCase() === 'transaction id')) {
                console.log('Detected format: PayPal');
                parsePayPalCSV(lines, headers, accountId);
            } else {
                console.log('Detected format: Generic');
                parseGenericCSV(lines, headers, accountId);
            }
            
            console.log('Parsed transactions count:', parsedTransactions.length);
        }

        // Parse Monzo CSV format
        function parseMonzoCSV(lines, headers, accountId) {
            parsedTransactions = [];
            
            // Find column indices
            const dateIdx = headers.indexOf('Date');
            const timeIdx = headers.indexOf('Time');
            const typeIdx = headers.indexOf('Type');
            const nameIdx = headers.indexOf('Name');
            const descriptionIdx = headers.indexOf('Description');
            const amountIdx = headers.indexOf('Amount');
            const categoryIdx = headers.indexOf('Category');
            const notesIdx = headers.indexOf('Notes and #tags');
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const values = parseCSVLine(line);
                
                if (values.length < headers.length) continue;
                
                const dateStr = values[dateIdx];
                const timeStr = values[timeIdx];
                const type = values[typeIdx];
                const name = values[nameIdx];
                const descriptionCol = values[descriptionIdx];
                const amount = parseFloat(values[amountIdx]);
                const note = values[notesIdx];
                
                if (!dateStr || isNaN(amount)) continue;
                
                // Combine Type, Name and Description
                let description = '';
                if (type && name) {
                    description = `${type} - ${name}`;
                } else {
                    description = name || type || '';
                }
                
                // Add Description column in parentheses if available
                if (descriptionCol && descriptionCol.trim() !== '') {
                    description += ` (${descriptionCol})`;
                }
                
                // Parse date - Monzo format is DD/MM/YYYY
                let date;
                try {
                    const dateParts = dateStr.split('/');
                    if (dateParts.length === 3) {
                        const day = dateParts[0].padStart(2, '0');
                        const month = dateParts[1].padStart(2, '0');
                        const year = dateParts[2];
                        
                        // Parse time - format is HH:MM:SS
                        let time = '12:00:00';
                        if (timeStr) {
                            time = timeStr;
                        }
                        
                        // Create ISO format: YYYY-MM-DDTHH:MM:SS
                        const datetime = `${year}-${month}-${day}T${time}`;
                        
                        parsedTransactions.push({
                            date: datetime,
                            description: description,
                            amount: amount,
                            note: note,
                            account_id: parseInt(accountId),
                            isDuplicate: false,
                            type: 'transaction',
                            payee_id: null,
                            category_id: null,
                            location_id: null,
                            project_id: null
                        });
                    }
                } catch (e) {
                    console.error('Error parsing date:', dateStr, e);
                    continue;
                }
            }
            
            // Check for duplicates
            checkDuplicates();
        }

        // Try to auto-suggest payee based on description
        function autoSuggestPayee(description, index) {
            if (!description) return;
            
            const descLower = description.toLowerCase();
            
            // Check if we already have a suggestion for this exact description
            if (payeeSuggestions[description]) {
                const payeeInput = document.getElementById(`payee_${index}`);
                payeeInput.value = payeeSuggestions[description];
                handlePayeeChange(index);
                return;
            }
            
            // Try to find a matching payee by name similarity
            for (const payee of allPayees) {
                const payeeLower = payee.name.toLowerCase();
                
                // Check if payee name is contained in description
                if (descLower.includes(payeeLower)) {
                    const payeeInput = document.getElementById(`payee_${index}`);
                    payeeInput.value = payee.name;
                    payeeSuggestions[description] = payee.name;
                    handlePayeeChange(index);
                    return;
                }
                
                // Check if description is contained in payee name
                if (payeeLower.includes(descLower)) {
                    const payeeInput = document.getElementById(`payee_${index}`);
                    payeeInput.value = payee.name;
                    payeeSuggestions[description] = payee.name;
                    handlePayeeChange(index);
                    return;
                }
            }
            
            // Try fuzzy matching with existing payees (check first words)
            const descWords = descLower.split(/[\s\-_]+/).filter(w => w.length > 2);
            
            for (const payee of allPayees) {
                const payeeWords = payee.name.toLowerCase().split(/[\s\-_]+/);
                
                // If any significant word matches
                for (const descWord of descWords) {
                    for (const payeeWord of payeeWords) {
                        if (descWord.includes(payeeWord) || payeeWord.includes(descWord)) {
                            const payeeInput = document.getElementById(`payee_${index}`);
                            payeeInput.value = payee.name;
                            payeeSuggestions[description] = payee.name;
                            handlePayeeChange(index);
                            return;
                        }
                    }
                }
            }
        }

        // Parse a CSV line handling quoted values
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            values.push(current.trim());
            return values;
        }

        // Check for duplicate transactions
        function checkDuplicates() {
            parsedTransactions.forEach(trans => {
                // Check if transaction already exists (same date, amount, account)
                const exists = existingTransactions.some(existing => {
                    const existingDate = new Date(existing.date);
                    const transDate = new Date(trans.date);
                    
                    return existing.account_id === trans.account_id &&
                        existing.amount === trans.amount &&
                        existingDate.getTime() === transDate.getTime();
                });
                
                trans.isDuplicate = exists;
            });
        }

        // Cancel import
        function cancelImport() {
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('previewSection').style.display = 'none';
            document.getElementById('fileInput').value = '';
            parsedTransactions = [];
            payeeSuggestions = {};
        }

        // Display transactions preview table
        function displayTransactionsPreview() {
            const tbody = document.getElementById('transactionsTableBody');
            tbody.innerHTML = '';
            
            let duplicateCount = 0;
            let newCount = 0;
            
            parsedTransactions.forEach((trans, index) => {
                if (trans.isDuplicate) {
                    duplicateCount++;
                } else {
                    newCount++;
                }
                
                const row = document.createElement('tr');
                if (trans.isDuplicate) {
                    row.classList.add('duplicate');
                }
                
                row.innerHTML = `
                    <td style="padding: 8px; text-align: center;">
                        <input type="checkbox" id="skip_${index}" onchange="handleSkipChange(${index})" 
                            style="width: 20px; height: 20px; cursor: pointer;">
                    </td>
                    <td style="padding: 8px;">
                        ${new Date(trans.date).toLocaleString('en-GB', { 
                            day: '2-digit', 
                            month: '2-digit', 
                            year: 'numeric',
                            hour: '2-digit',
                            minute: '2-digit'
                        })}
                    </td>
                    <td style="padding: 8px;">${trans.description || ''}</td>
                    <td style="padding: 8px; text-align: right; font-weight: bold; color: ${trans.amount < 0 ? '#ef4444' : '#10b981'};">
                        ¬£${Math.abs(trans.amount).toFixed(2)}
                    </td>
                    <td style="padding: 8px;">
                        <select id="type_${index}" onchange="handleTypeChange(${index})" style="width: 100%;">
                            <option value="transaction">Transaction</option>
                            <option value="transfer">Transfer</option>
                        </select>
                    </td>
                    <td style="padding: 8px;">
                        <input list="payees_${index}" id="payee_${index}" 
                            placeholder="Select or type payee..." 
                            onchange="handlePayeeChange(${index})"
                            style="width: 100%;">
                        <datalist id="payees_${index}">
                            ${allPayees.map(p => `<option value="${p.name}" data-id="${p.id}">`).join('')}
                        </datalist>
                        <select id="account_${index}" style="width: 100%; display: none;">
                            <option value="">Select account...</option>
                            ${allAccountsForImport.map(acc => `<option value="${acc.id}">${acc.name}</option>`).join('')}
                        </select>
                    </td>
                    <td style="padding: 8px;">
                        <select id="parentCategory_${index}" onchange="handleParentCategoryChange(${index})" style="width: 100%; margin-bottom: 4px;">
                            <option value="">Select parent...</option>
                            ${getUniqueParents().map(p => `<option value="${p}">${p}</option>`).join('')}
                        </select>
                        <select id="category_${index}" disabled style="width: 100%;">
                            <option value="">Select category...</option>
                        </select>
                    </td>
                    <td style="padding: 8px;">
                        <select id="location_${index}" style="width: 100%;">
                            <option value="">None</option>
                            ${allLocations.map(l => `<option value="${l.id}">${l.name}</option>`).join('')}
                        </select>
                    </td>
                    <td style="padding: 8px;">
                        <select id="project_${index}" style="width: 100%;">
                            <option value="">None</option>
                            ${allProjects.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                        </select>
                    </td>
                    <td style="padding: 8px;">
                        <textarea id="note_${index}" 
                                rows="2" 
                                placeholder="Optional note..."
                                style="width: 100%; padding: 6px; border: 1px solid #e0e0e0; border-radius: 4px; font-size: 12px; resize: vertical;"
                                onchange="parsedTransactions[${index}].note = this.value">${trans.note || ''}</textarea>
                    </td>
                    <td style="padding: 8px; text-align: center;">
                        ${trans.isDuplicate ? 
                            '<span style="color: #ef4444; font-weight: bold;">‚ö†Ô∏è Duplicate</span>' : 
                            '<span style="color: #10b981; font-weight: bold;">‚úì New</span>'}
                    </td>
                `;
                
                tbody.appendChild(row);

                // Try to auto-suggest payee based on description
                if (!trans.isDuplicate && trans.type === 'transaction') {
                    setTimeout(() => autoSuggestPayee(trans.description, index), 10);
                }
            });
            
            // Update counts
            document.getElementById('totalTransactions').textContent = parsedTransactions.length;
            document.getElementById('duplicateCount').textContent = duplicateCount;
            document.getElementById('newCount').textContent = newCount;
            document.getElementById('importCount').textContent = newCount;
        }

        // Get unique parent categories
        function getUniqueParents() {
            const parents = new Set();
            allCategories.forEach(cat => {
                if (cat.parent) {
                    parents.add(cat.parent);
                }
            });
            return Array.from(parents).sort();
        }

        // Handle type change (Transaction vs Transfer)
        function handleTypeChange(index) {
            const type = document.getElementById(`type_${index}`).value;
            const payeeInput = document.getElementById(`payee_${index}`);
            const accountSelect = document.getElementById(`account_${index}`);
            const categoryParent = document.getElementById(`parentCategory_${index}`);
            const categorySelect = document.getElementById(`category_${index}`);
            const locationSelect = document.getElementById(`location_${index}`);
            const projectSelect = document.getElementById(`project_${index}`);
            
            if (type === 'transfer') {
                // Show account selector, hide payee and disable category/location/project
                payeeInput.style.display = 'none';
                accountSelect.style.display = 'block';
                categoryParent.disabled = true;
                categorySelect.disabled = true;
                locationSelect.disabled = true;
                projectSelect.disabled = true;
                
                parsedTransactions[index].type = 'transfer';
                
                // Add listener to check currency difference
                accountSelect.onchange = () => checkCurrencyDifference(index);
                
            } else {
                // Show payee input, hide account selector, enable others
                payeeInput.style.display = 'block';
                accountSelect.style.display = 'none';
                categoryParent.disabled = false;
                locationSelect.disabled = false;
                projectSelect.disabled = false;
                
                parsedTransactions[index].type = 'transaction';
                
                // Remove currency conversion field if exists
                const existingConversion = document.getElementById(`currencyConversion_${index}`);
                if (existingConversion) {
                    existingConversion.remove();
                }
            }
        }

        // Check if currencies are different and show conversion field
        function checkCurrencyDifference(index) {
            const trans = parsedTransactions[index];
            const toAccountId = document.getElementById(`account_${index}`).value;
            
            if (!toAccountId) return;
            
            // Get currencies
            const fromAccount = allAccountsForImport.find(a => a.id === trans.account_id);
            const toAccount = allAccountsForImport.find(a => a.id === parseInt(toAccountId));
            
            const td = document.getElementById(`account_${index}`).parentElement;
            
            // Remove existing conversion field if any
            const existingConversion = document.getElementById(`currencyConversion_${index}`);
            if (existingConversion) {
                existingConversion.remove();
            }
            
            if (fromAccount.currency !== toAccount.currency) {
                // Different currencies - show conversion field
                const conversionDiv = document.createElement('div');
                conversionDiv.id = `currencyConversion_${index}`;
                conversionDiv.style.marginTop = '8px';
                conversionDiv.innerHTML = `
                    <div style="background: #fff3cd; padding: 8px; border-radius: 4px; border: 1px solid #ffc107;">
                        <div style="font-size: 11px; color: #856404; margin-bottom: 4px;">
                            <strong>Currency conversion required</strong>
                        </div>
                        <div style="font-size: 12px; margin-bottom: 4px;">
                            From: ${fromAccount.currency} ${Math.abs(trans.amount).toFixed(2)}
                        </div>
                        <label style="font-size: 12px; display: block; margin-bottom: 4px;">
                            Amount received in ${toAccount.currency}:
                        </label>
                        <input type="number" 
                            id="convertedAmount_${index}" 
                            step="0.01" 
                            placeholder="Enter amount in ${toAccount.currency}"
                            style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                            onchange="parsedTransactions[${index}].convertedAmount = parseFloat(this.value)">
                    </div>
                `;
                td.appendChild(conversionDiv);
            }
        }

        // Handle payee change
        async function handlePayeeChange(index) {
            const payeeInput = document.getElementById(`payee_${index}`);
            const payeeName = payeeInput.value.trim();
            
            if (!payeeName) return;
            
            // Find or suggest payee
            let payee = allPayees.find(p => p.name.toLowerCase() === payeeName.toLowerCase());
            
            if (payee) {
                parsedTransactions[index].payee_id = payee.id;
                
                // Auto-fill category, location, project based on most common for this payee
                await autoFillFromPayee(index, payee.id);
                
                // Store suggestion for similar descriptions
                payeeSuggestions[parsedTransactions[index].description] = payeeName;
                
                // Apply suggestion to other transactions with same description
                applySuggestionToSimilar(index);
            } else {
                parsedTransactions[index].payee_id = null;
            }
        }

        // Auto-fill fields based on most common values for this payee
        async function autoFillFromPayee(index, payeeId) {
            try {
                // Get all transactions for this payee
                const response = await fetch(`${API_URL}/transactions?limit=100000`);
                const allTransactions = await response.json();
                
                const payeeTransactions = allTransactions.filter(t => t.payee_id === payeeId);
                
                if (payeeTransactions.length === 0) return;
                
                // Find most common category
                const categoryCounts = {};
                const locationCounts = {};
                const projectCounts = {};
                
                payeeTransactions.forEach(t => {
                    if (t.category_id) {
                        categoryCounts[t.category_id] = (categoryCounts[t.category_id] || 0) + 1;
                    }
                    if (t.location_id) {
                        locationCounts[t.location_id] = (locationCounts[t.location_id] || 0) + 1;
                    }
                    if (t.project_id) {
                        projectCounts[t.project_id] = (projectCounts[t.project_id] || 0) + 1;
                    }
                });
                
                // Get most common values
                const mostCommonCategory = Object.keys(categoryCounts).reduce((a, b) => 
                    categoryCounts[a] > categoryCounts[b] ? a : b, null);
                const mostCommonLocation = Object.keys(locationCounts).reduce((a, b) => 
                    locationCounts[a] > locationCounts[b] ? a : b, null);
                const mostCommonProject = Object.keys(projectCounts).reduce((a, b) => 
                    projectCounts[a] > projectCounts[b] ? a : b, null);
                
                // Set the values
                if (mostCommonCategory) {
                    const category = allCategories.find(c => c.id === parseInt(mostCommonCategory));
                    if (category && category.parent) {
                        document.getElementById(`parentCategory_${index}`).value = category.parent;
                        handleParentCategoryChange(index);
                        setTimeout(() => {
                            document.getElementById(`category_${index}`).value = mostCommonCategory;
                            parsedTransactions[index].category_id = parseInt(mostCommonCategory);
                        }, 100);
                    }
                }
                
                if (mostCommonLocation) {
                    document.getElementById(`location_${index}`).value = mostCommonLocation;
                    parsedTransactions[index].location_id = parseInt(mostCommonLocation);
                }
                
                if (mostCommonProject) {
                    document.getElementById(`project_${index}`).value = mostCommonProject;
                    parsedTransactions[index].project_id = parseInt(mostCommonProject);
                }
                
            } catch (error) {
                console.error('Error auto-filling from payee:', error);
            }
        }

        // Apply payee suggestion to other transactions with same description
        function applySuggestionToSimilar(sourceIndex) {
            const sourceDescription = parsedTransactions[sourceIndex].description;
            const suggestedPayee = payeeSuggestions[sourceDescription];
            
            if (!suggestedPayee) return;
            
            // Apply to all other transactions with same description
            parsedTransactions.forEach((trans, index) => {
                if (index !== sourceIndex && trans.description === sourceDescription) {
                    const payeeInput = document.getElementById(`payee_${index}`);
                    if (!payeeInput.value) { // Only if not already filled
                        payeeInput.value = suggestedPayee;
                        handlePayeeChange(index);
                    }
                }
            });
        }

        // Handle parent category change
        function handleParentCategoryChange(index) {
            const parentValue = document.getElementById(`parentCategory_${index}`).value;
            const categorySelect = document.getElementById(`category_${index}`);
            
            categorySelect.innerHTML = '<option value="">Select category...</option>';
            
            if (!parentValue) {
                categorySelect.disabled = true;
                return;
            }
            
            // Filter categories by parent
            const subcategories = allCategories
                .filter(c => c.parent === parentValue)
                .sort((a, b) => a.name.localeCompare(b.name));
            
            if (subcategories.length === 0) {
                categorySelect.disabled = true;
                return;
            }
            
            categorySelect.disabled = false;
            subcategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                categorySelect.appendChild(option);
            });
        }

        // Handle skip checkbox change
        function handleSkipChange(index) {
            const skipCheckbox = document.getElementById(`skip_${index}`);
            const row = skipCheckbox.closest('tr');
            
            parsedTransactions[index].skip = skipCheckbox.checked;
            
            if (skipCheckbox.checked) {
                row.style.opacity = '0.4';
                row.style.background = '#f0f0f0';
            } else {
                row.style.opacity = '1';
                row.style.background = parsedTransactions[index].isDuplicate ? '#fee' : '';
            }
            
            // Update counts
            updateImportCounts();
        }

        // Update import counts
        function updateImportCounts() {
            let duplicateCount = 0;
            let newCount = 0;
            let skippedCount = 0;
            
            parsedTransactions.forEach(trans => {
                if (trans.skip) {
                    skippedCount++;
                } else if (trans.isDuplicate) {
                    duplicateCount++;
                } else {
                    newCount++;
                }
            });
            
            document.getElementById('duplicateCount').textContent = duplicateCount;
            document.getElementById('newCount').textContent = newCount;
            document.getElementById('importCount').textContent = newCount;
        }

        // Import transactions
        async function importTransactions() {
            const transactionsToImport = parsedTransactions.filter(t => !t.isDuplicate && !t.skip);
            
            if (transactionsToImport.length === 0) {
                showError('No new transactions to import');
                return;
            }
            
            if (!confirm(`Import ${transactionsToImport.length} transactions?`)) {
                return;
            }
            
            try {
                let successCount = 0;
                let errorCount = 0;
                const errors = [];
                
                for (let i = 0; i < parsedTransactions.length; i++) {
                    const trans = parsedTransactions[i];
                    
                    if (trans.isDuplicate || trans.skip) continue;
                    
                    try {
                        // Get values from form
                        const type = document.getElementById(`type_${i}`).value;
                        
                        if (type === 'transfer') {
                            // Handle transfer
                            const toAccountId = document.getElementById(`account_${i}`).value;
                            
                            if (!toAccountId) {
                                errors.push(`Transaction ${i + 1}: No destination account selected`);
                                errorCount++;
                                continue;
                            }
                            
                            // Check if there's a converted amount
                            let toAmount = null;
                            const convertedAmountInput = document.getElementById(`convertedAmount_${i}`);
                            if (convertedAmountInput) {
                                const value = parseFloat(convertedAmountInput.value);
                                if (!isNaN(value) && value > 0) {
                                    toAmount = value;
                                }
                            }
                            
                            const transferData = {
                                date: trans.date,
                                from_account_id: trans.amount < 0 ? trans.account_id : parseInt(toAccountId),
                                to_account_id: trans.amount < 0 ? parseInt(toAccountId) : trans.account_id,
                                from_amount: Math.abs(trans.amount),
                                to_amount: toAmount,
                                note: trans.note
                            };
                            
                            const response = await fetch(`${API_URL}/transactions/transfer`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(transferData)
                            });
                            
                            if (response.ok) {
                                successCount++;
                            } else {
                                const errorText = await response.text();
                                errors.push(`Transaction ${i + 1} (transfer): ${errorText}`);
                                errorCount++;
                            }
                            
                        } else {
                            // Handle regular transaction
                            const payeeInput = document.getElementById(`payee_${i}`).value.trim();
                            let payeeId = null;
                            
                            // Create payee if doesn't exist
                            if (payeeInput) {
                                let payee = allPayees.find(p => p.name.toLowerCase() === payeeInput.toLowerCase());
                                
                                if (!payee) {
                                    console.log('Creating new payee:', payeeInput);
                                    
                                    try {
                                        const createResponse = await fetch(`${API_URL}/payees`, {
                                            method: 'POST',
                                            headers: { 'Content-Type': 'application/json' },
                                            body: JSON.stringify({ name: payeeInput })
                                        });
                                        
                                        if (createResponse.ok) {
                                            payee = await createResponse.json();
                                            allPayees.push(payee);
                                            console.log('Payee created successfully:', payee);
                                        } else {
                                            const errorText = await createResponse.text();
                                            console.error('Error creating payee:', errorText);
                                            
                                            // Try to parse error message
                                            try {
                                                const errorJson = JSON.parse(errorText);
                                                errors.push(`Transaction ${i + 1}: Failed to create payee "${payeeInput}": ${errorJson.detail || errorText}`);
                                            } catch {
                                                errors.push(`Transaction ${i + 1}: Failed to create payee "${payeeInput}": ${errorText}`);
                                            }
                                            
                                            errorCount++;
                                            continue;
                                        }
                                    } catch (payeeError) {
                                        console.error('Exception creating payee:', payeeError);
                                        errors.push(`Transaction ${i + 1}: Exception creating payee "${payeeInput}": ${payeeError.message}`);
                                        errorCount++;
                                        continue;
                                    }
                                }
                                
                                if (payee) {
                                    payeeId = payee.id;
                                }
                            }
                            
                            const categoryId = document.getElementById(`category_${i}`).value;
                            const locationId = document.getElementById(`location_${i}`).value;
                            const projectId = document.getElementById(`project_${i}`).value;
                            
                            const transactionData = {
                                date: trans.date,
                                amount: trans.amount,
                                currency: 'GBP',
                                account_id: trans.account_id,
                                category_id: categoryId ? parseInt(categoryId) : null,
                                payee_id: payeeId,
                                location_id: locationId ? parseInt(locationId) : null,
                                project_id: projectId ? parseInt(projectId) : null,
                                note: trans.note
                            };
                            
                            const response = await fetch(`${API_URL}/transactions`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify(transactionData)
                            });
                            
                            if (response.ok) {
                                successCount++;
                            } else {
                                const errorText = await response.text();
                                errors.push(`Transaction ${i + 1}: ${errorText}`);
                                errorCount++;
                            }
                        }
                    } catch (transError) {
                        console.error(`Error processing transaction ${i}:`, transError);
                        errors.push(`Transaction ${i + 1}: ${transError.message}`);
                        errorCount++;
                    }
                }
                
                // Show results
                let message = '';
                if (successCount > 0) {
                    message += `‚úÖ Successfully imported ${successCount} transactions!\n`;
                }
                
                if (errorCount > 0) {
                    message += `\n‚ùå Failed to import ${errorCount} transactions:\n`;
                    message += errors.slice(0, 5).join('\n'); // Show first 5 errors
                    if (errors.length > 5) {
                        message += `\n... and ${errors.length - 5} more errors`;
                    }
                    message += '\n\nCheck browser console (F12) for full details.';
                    console.error('Import errors:', errors);
                }
                
                if (successCount > 0 && errorCount === 0) {
                    showSuccess(message);
                    // Close modal and reset
                    closeModal('importModal');
                    cancelImport();
                } else if (successCount > 0 && errorCount > 0) {
                    showError(message);
                    // Don't close modal so user can review
                } else {
                    showError(message);
                }
                
            } catch (error) {
                console.error('Error importing transactions:', error);
                showError('Error importing transactions: ' + error.message + '\n\nCheck browser console (F12) for details');
            }
        }

        // Parse generic CSV format
        function parseGenericCSV(lines, headers, accountId) {
            parsedTransactions = [];
            
            // Try to detect common column names
            const dateIdx = headers.findIndex(h => 
                h.toLowerCase().includes('date') || h.toLowerCase().includes('fecha'));
            const descIdx = headers.findIndex(h => 
                h.toLowerCase().includes('description') || h.toLowerCase().includes('concept') || 
                h.toLowerCase().includes('name') || h.toLowerCase().includes('descripci√≥n'));
            const amountIdx = headers.findIndex(h => 
                h.toLowerCase().includes('amount') || h.toLowerCase().includes('importe'));
            
            if (dateIdx === -1 || amountIdx === -1) {
                throw new Error('Could not detect date and amount columns. Please use a supported format.');
            }
            
            // Track time for transactions on same day
            let lastDate = null;
            let timeCounter = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const values = parseCSVLine(line);
                
                if (values.length < headers.length) continue;
                
                const dateStr = values[dateIdx];
                const description = descIdx !== -1 ? values[descIdx] : '';
                const amountStr = values[amountIdx].replace(/[¬£‚Ç¨$,]/g, '');
                const amount = parseFloat(amountStr);
                
                if (!dateStr || isNaN(amount)) continue;
                
                // Parse date and add time
                let date;
                try {
                    date = new Date(dateStr);
                    if (isNaN(date.getTime())) {
                        // Try UK format DD/MM/YYYY
                        const parts = dateStr.split('/');
                        if (parts.length === 3) {
                            date = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
                        }
                    }
                } catch (e) {
                    continue;
                }
                
                // Handle time assignment for same day transactions
                const dateOnly = date.toDateString();
                if (dateOnly !== lastDate) {
                    lastDate = dateOnly;
                    timeCounter = 0;
                }
                
                // Set time: 12:00 for first transaction of the day, then increment by minute
                const hours = 12;
                const minutes = timeCounter;
                timeCounter++;
                
                const datetime = new Date(date);
                datetime.setHours(hours, minutes, 0, 0);
                
                parsedTransactions.push({
                    date: datetime.toISOString().slice(0, 19),
                    description: description,
                    amount: amount,
                    note: '',
                    account_id: parseInt(accountId),
                    isDuplicate: false,
                    type: 'transaction',
                    payee_id: null,
                    category_id: null,
                    location_id: null,
                    project_id: null
                });
            }
            
            // Check for duplicates
            checkDuplicates();
        }

        // Parse Bank of Scotland CSV format
        function parseBankOfScotlandCSV(lines, headers, accountId) {
            console.log('=== Starting Bank of Scotland CSV Parse ===');
            console.log('Headers:', headers);
            
            parsedTransactions = [];
            
            // Bank of Scotland CSV includes Sort Code and Account Number columns
            // Find indices dynamically to handle column order
            const dateIdx = headers.findIndex(h => h.toLowerCase().includes('transaction date'));
            const typeIdx = headers.findIndex(h => h.toLowerCase().includes('transaction type'));
            const descIdx = headers.findIndex(h => h.toLowerCase().includes('transaction description'));
            const debitIdx = headers.findIndex(h => h.toLowerCase().includes('debit amount'));
            const creditIdx = headers.findIndex(h => h.toLowerCase().includes('credit amount'));
            const balanceIdx = headers.findIndex(h => h.toLowerCase().includes('balance'));
            
            console.log('Column indices found:');
            console.log('  Date:', dateIdx);
            console.log('  Type:', typeIdx);
            console.log('  Description:', descIdx);
            console.log('  Debit:', debitIdx);
            console.log('  Credit:', creditIdx);
            console.log('  Balance:', balanceIdx);
            
            // Validate that we found all required columns
            if (dateIdx === -1 || descIdx === -1 || debitIdx === -1 || creditIdx === -1) {
                const missingColumns = [];
                if (dateIdx === -1) missingColumns.push('Transaction Date');
                if (descIdx === -1) missingColumns.push('Transaction Description');
                if (debitIdx === -1) missingColumns.push('Debit Amount');
                if (creditIdx === -1) missingColumns.push('Credit Amount');
                
                throw new Error('Could not find required columns: ' + missingColumns.join(', ') + 
                            '\n\nFound headers: ' + headers.join(', '));
            }
            
            // Track time for transactions on same day
            let lastDate = null;
            let timeCounter = 0;
            let successCount = 0;
            let skipCount = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) {
                    skipCount++;
                    continue;
                }
                
                try {
                    const values = parseCSVLine(line);
                    
                    // Log first transaction for debugging
                    if (i === 1) {
                        console.log('First data line values:', values);
                    }
                    
                    // Skip if we don't have enough values
                    const maxIdx = Math.max(dateIdx, typeIdx, descIdx, debitIdx, creditIdx, balanceIdx);
                    if (values.length <= maxIdx) {
                        console.warn(`Line ${i}: Not enough values (${values.length} vs required ${maxIdx + 1})`);
                        skipCount++;
                        continue;
                    }
                    
                    const dateStr = values[dateIdx];
                    const type = typeIdx !== -1 ? values[typeIdx] : '';
                    const description = values[descIdx];
                    
                    // Parse debit and credit amounts, removing any quotes
                    const debitStr = values[debitIdx].replace(/['"]/g, '').trim();
                    const creditStr = values[creditIdx].replace(/['"]/g, '').trim();
                    
                    const debit = debitStr ? parseFloat(debitStr) : 0;
                    const credit = creditStr ? parseFloat(creditStr) : 0;
                    
                    if (!dateStr) {
                        skipCount++;
                        continue;
                    }
                    
                    // Calculate amount (credit is positive, debit is negative)
                    const amount = credit > 0 ? credit : -debit;
                    
                    if (amount === 0) {
                        skipCount++;
                        continue;
                    }
                    
                    // Parse date (format: DD/MM/YYYY)
                    let date;
                    const dateParts = dateStr.split('/');
                    if (dateParts.length === 3) {
                        const day = dateParts[0].padStart(2, '0');
                        const month = dateParts[1].padStart(2, '0');
                        const year = dateParts[2];
                        
                        date = new Date(`${year}-${month}-${day}`);
                        
                        if (isNaN(date.getTime())) {
                            throw new Error(`Invalid date: ${dateStr}`);
                        }
                    } else {
                        throw new Error(`Invalid date format: ${dateStr} (expected DD/MM/YYYY)`);
                    }
                    
                    // Handle time assignment
                    const dateOnly = date.toDateString();
                    if (dateOnly !== lastDate) {
                        lastDate = dateOnly;
                        timeCounter = 0;
                    }
                    
                    const hours = 12;
                    const minutes = timeCounter;
                    timeCounter++;
                    
                    const datetime = new Date(date);
                    datetime.setHours(hours, minutes, 0, 0);
                    
                    // Combine type and description for better context
                    const fullDescription = type && description ? `${type} - ${description}` : (description || type || '');
                    
                    parsedTransactions.push({
                        date: datetime.toISOString().slice(0, 19),
                        description: fullDescription,
                        amount: amount,
                        note: '',
                        account_id: parseInt(accountId),
                        isDuplicate: false,
                        type: 'transaction',
                        payee_id: null,
                        category_id: null,
                        location_id: null,
                        project_id: null
                    });
                    
                    successCount++;
                    
                } catch (error) {
                    console.error(`Error parsing line ${i}:`, error.message);
                    console.error('Line content:', line);
                    // Continue processing other lines instead of failing completely
                    skipCount++;
                }
            }
            
            console.log(`Parse complete: ${successCount} successful, ${skipCount} skipped`);
            
            checkDuplicates();
            
            if (parsedTransactions.length === 0) {
                throw new Error('No transactions found in CSV. Please check the file format.\n\n' +
                            `Processed ${lines.length - 1} lines, but none were valid transactions.`);
            }
            
            console.log('=== Bank of Scotland CSV Parse Complete ===');
        }

        // Parse PayPal CSV format
        function parsePayPalCSV(lines, headers, accountId) {
            console.log('=== Starting PayPal CSV Parse ===');
            console.log('Headers:', headers);
            
            parsedTransactions = [];
            
            // Find column indices
            const dateIdx = headers.findIndex(h => h.toLowerCase() === 'date');
            const timeIdx = headers.findIndex(h => h.toLowerCase() === 'time');
            const descriptionIdx = headers.findIndex(h => h.toLowerCase() === 'description');
            const currencyIdx = headers.findIndex(h => h.toLowerCase() === 'currency');
            const grossIdx = headers.findIndex(h => h.toLowerCase() === 'gross');
            const feeIdx = headers.findIndex(h => h.toLowerCase() === 'fee');
            const netIdx = headers.findIndex(h => h.toLowerCase() === 'net');
            const nameIdx = headers.findIndex(h => h.toLowerCase() === 'name');
            const invoiceIdx = headers.findIndex(h => h.toLowerCase() === 'invoice id');
            
            console.log('Column indices found:');
            console.log('  Date:', dateIdx);
            console.log('  Time:', timeIdx);
            console.log('  Description:', descriptionIdx);
            console.log('  Currency:', currencyIdx);
            console.log('  Gross:', grossIdx);
            console.log('  Fee:', feeIdx);
            console.log('  Net:', netIdx);
            console.log('  Name:', nameIdx);
            console.log('  Invoice:', invoiceIdx);
            
            // Validate required columns
            if (dateIdx === -1 || timeIdx === -1 || grossIdx === -1 || descriptionIdx === -1) {
                const missingColumns = [];
                if (dateIdx === -1) missingColumns.push('Date');
                if (timeIdx === -1) missingColumns.push('Time');
                if (grossIdx === -1) missingColumns.push('Gross');
                if (descriptionIdx === -1) missingColumns.push('Description');
                
                throw new Error('Could not find required PayPal columns: ' + missingColumns.join(', ') + 
                            '\n\nFound headers: ' + headers.join(', '));
            }
            
            let successCount = 0;
            let skipCount = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) {
                    skipCount++;
                    continue;
                }
                
                try {
                    const values = parseCSVLine(line);
                    
                    // Log first transaction for debugging
                    if (i === 1) {
                        console.log('First data line values:', values);
                    }
                    
                    const maxIdx = Math.max(dateIdx, timeIdx, descriptionIdx, grossIdx, nameIdx, invoiceIdx);
                    if (values.length <= maxIdx) {
                        console.warn(`Line ${i}: Not enough values (${values.length} vs required ${maxIdx + 1})`);
                        skipCount++;
                        continue;
                    }
                    
                    const dateStr = values[dateIdx].replace(/"/g, '');
                    const timeStr = values[timeIdx].replace(/"/g, '');
                    const description = values[descriptionIdx].replace(/"/g, '');
                    const grossStr = values[grossIdx].replace(/"/g, '').trim();
                    const feeStr = feeIdx !== -1 ? values[feeIdx].replace(/"/g, '').trim() : '0.00';
                    const merchantName = nameIdx !== -1 ? values[nameIdx].replace(/"/g, '').trim() : '';
                    const invoiceId = invoiceIdx !== -1 ? values[invoiceIdx].replace(/"/g, '').trim() : '';
                    
                    // Skip "BML Credit" entries as they're just funding transactions
                    if (description.includes('BML Credit') || description.includes('Transfer from BML')) {
                        skipCount++;
                        continue;
                    }
                    
                    if (!dateStr || !grossStr) {
                        skipCount++;
                        continue;
                    }
                    
                    const gross = parseFloat(grossStr);
                    const fee = parseFloat(feeStr);
                    
                    if (isNaN(gross)) {
                        skipCount++;
                        continue;
                    }
                    
                    // Parse date (format: DD/MM/YYYY)
                    let date;
                    const dateParts = dateStr.split('/');
                    if (dateParts.length === 3) {
                        const day = dateParts[0].padStart(2, '0');
                        const month = dateParts[1].padStart(2, '0');
                        const year = dateParts[2];
                        
                        // Parse time (format: HH:MM:SS)
                        const time = timeStr || '12:00:00';
                        
                        // Create ISO format datetime
                        const datetime = `${year}-${month}-${day}T${time}`;
                        
                        // Build description combining merchant name and transaction type
                        let fullDescription = '';
                        if (merchantName) {
                            fullDescription = merchantName;
                            if (description && !description.includes('Express Checkout')) {
                                fullDescription += ` (${description})`;
                            }
                        } else {
                            fullDescription = description;
                        }
                        
                        // Build note with additional info
                        let note = '';
                        if (invoiceId) {
                            note = `Invoice: ${invoiceId}`;
                        }
                        if (fee !== 0) {
                            note += (note ? ' | ' : '') + `Fee: ¬£${fee.toFixed(2)}`;
                        }
                        
                        parsedTransactions.push({
                            date: datetime,
                            description: fullDescription,
                            amount: gross,
                            note: note,
                            account_id: parseInt(accountId),
                            isDuplicate: false,
                            type: 'transaction',
                            payee_id: null,
                            category_id: null,
                            location_id: null,
                            project_id: null
                        });
                        
                        successCount++;
                    } else {
                        throw new Error(`Invalid date format: ${dateStr} (expected DD/MM/YYYY)`);
                    }
                    
                } catch (error) {
                    console.error(`Error parsing line ${i}:`, error.message);
                    console.error('Line content:', line);
                    skipCount++;
                }
            }
            
            console.log(`Parse complete: ${successCount} successful, ${skipCount} skipped`);
            
            checkDuplicates();
            
            if (parsedTransactions.length === 0) {
                throw new Error('No transactions found in CSV. Please check the file format.\n\n' +
                            `Processed ${lines.length - 1} lines, but none were valid transactions.`);
            }
            
            console.log('=== PayPal CSV Parse Complete ===');
        }

        // Load data for export
        async function loadExportData() {
            try {
                // Load accounts for filter
                const accountsResponse = await fetch(`${API_URL}/accounts`);
                const accounts = await accountsResponse.json();
                
                const exportAccountSelect = document.getElementById('exportAccount');
                exportAccountSelect.innerHTML = '<option value="">All accounts</option>';
                accounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    exportAccountSelect.appendChild(option);
                });
                
                // Load categories for filter
                await loadCategories();
                
                const exportParentSelect = document.getElementById('exportParentCategory');
                exportParentSelect.innerHTML = '<option value="">All categories</option>';
                
                const parents = [...new Set(allCategories
                    .map(c => c.parent)
                    .filter(p => p && p.trim() !== ''))]
                    .sort();
                
                parents.forEach(parent => {
                    const option = document.createElement('option');
                    option.value = parent;
                    option.textContent = parent;
                    exportParentSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading export data:', error);
                showError('Failed to load export options');
            }
        }

        // Load subcategories for export
        function loadExportSubcategories() {
            const parentValue = document.getElementById('exportParentCategory').value;
            const categorySelect = document.getElementById('exportCategory');
            
            categorySelect.innerHTML = '<option value="">All subcategories</option>';
            
            if (!parentValue) {
                categorySelect.disabled = true;
                return;
            }
            
            const subcategories = allCategories
                .filter(c => c.parent === parentValue)
                .sort((a, b) => a.name.localeCompare(b.name));
            
            if (subcategories.length === 0) {
                categorySelect.disabled = true;
                return;
            }
            
            categorySelect.disabled = false;
            subcategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                categorySelect.appendChild(option);
            });
        }

        // Export to CSV
        async function exportToCSV() {
            try {
                // Get filter values
                const startDate = document.getElementById('exportStartDate').value;
                const endDate = document.getElementById('exportEndDate').value;
                const accountId = document.getElementById('exportAccount').value;
                const categoryId = document.getElementById('exportCategory').value;
                const format = document.getElementById('exportFormat').value;
                
                // Build query parameters
                let url = `${API_URL}/transactions?limit=100000`;
                
                if (startDate) {
                    url += `&start_date=${startDate}`;
                }
                if (endDate) {
                    url += `&end_date=${endDate}`;
                }
                if (accountId) {
                    url += `&account_id=${accountId}`;
                }
                if (categoryId) {
                    url += `&category_id=${categoryId}`;
                }
                
                // Fetch transactions
                const response = await fetch(url);
                const transactions = await response.json();
                
                if (transactions.length === 0) {
                    showError('No transactions found with selected filters');
                    return;
                }
                
                // Generate CSV content
                let csvContent = '';
                
                if (format === 'standard') {
                    // Standard format: Date, Description, Amount, Category, Account
                    csvContent = 'Date,Time,Description,Amount,Currency,Category,Account,Payee,Location,Project,Note\n';
                    
                    transactions.forEach(t => {
                        const date = new Date(t.date);
                        const dateStr = date.toLocaleDateString('en-GB');
                        const timeStr = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                        const description = (t.payee_name || 'No payee').replace(/,/g, ';');
                        const amount = t.amount.toFixed(2);
                        const category = (t.category_name || 'Uncategorised').replace(/,/g, ';');
                        const account = (t.account_name || '').replace(/,/g, ';');
                        const payee = (t.payee_name || '').replace(/,/g, ';');
                        const location = (t.location_name || '').replace(/,/g, ';');
                        const project = (t.project_name || '').replace(/,/g, ';');
                        const note = (t.note || '').replace(/,/g, ';');
                        
                        csvContent += `${dateStr},${timeStr},"${description}",${amount},${t.currency},"${category}","${account}","${payee}","${location}","${project}","${note}"\n`;
                    });
                } else {
                    // Detailed format: All fields including IDs
                    csvContent = 'ID,Date,Time,Amount,Currency,Account ID,Account Name,Category ID,Category Name,Payee ID,Payee Name,Location ID,Location Name,Project ID,Project Name,Note,Created At,Updated At\n';
                    
                    transactions.forEach(t => {
                        const date = new Date(t.date);
                        const dateStr = date.toLocaleDateString('en-GB');
                        const timeStr = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                        const amount = t.amount.toFixed(2);
                        const note = (t.note || '').replace(/,/g, ';').replace(/"/g, '""');
                        const accountName = (t.account_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const categoryName = (t.category_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const payeeName = (t.payee_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const locationName = (t.location_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const projectName = (t.project_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        
                        csvContent += `${t.id},${dateStr},${timeStr},${amount},${t.currency},`;
                        csvContent += `${t.account_id || ''},"${accountName}",`;
                        csvContent += `${t.category_id || ''},"${categoryName}",`;
                        csvContent += `${t.payee_id || ''},"${payeeName}",`;
                        csvContent += `${t.location_id || ''},"${locationName}",`;
                        csvContent += `${t.project_id || ''},"${projectName}",`;
                        csvContent += `"${note}","${t.created_at || ''}","${t.updated_at || ''}"\n`;
                    });
                }
                
                // Create download link
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const downloadUrl = URL.createObjectURL(blob);

                // Generate filename with date
                const now = new Date();
                const filename = `financisto_export_${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2,'0')}-${now.getDate().toString().padStart(2,'0')}.csv`;

                link.setAttribute('href', downloadUrl);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showSuccess(`Exported ${transactions.length} transactions successfully!`);
                closeModal('exportModal');

                } catch (error) {
                    console.error('Error exporting to CSV:', error);
                    showError('Error exporting data: ' + error.message);
                }
        }

        // Download database backup
        async function downloadDatabaseBackup() {
            const statusDiv = document.getElementById('backupStatus');
            
            try {
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.innerHTML = '‚è≥ Creating backup...';
                
                // Call the backup endpoint
                const response = await fetch(`${API_URL}/admin/backup-database`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create backup');
                }
                
                // Get the blob from response
                const blob = await response.blob();
                
                // Generate filename with timestamp
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
                const filename = `finance_backup_${timestamp}.db`;
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
                
                // Show success message
                statusDiv.style.background = '#d1f2eb';
                statusDiv.style.color = '#0f5132';
                statusDiv.innerHTML = `‚úÖ Backup downloaded successfully!<br><small>${filename}</small>`;
                
                showSuccess(`Database backup downloaded: ${filename}`);
                
                // Close modal after 2 seconds
                setTimeout(() => {
                    closeModal('backupModal');
                }, 2000);
                
            } catch (error) {
                console.error('Error creating backup:', error);
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#842029';
                statusDiv.innerHTML = '‚ùå Failed to create backup. Please try again.';
                showError('Failed to create backup: ' + error.message);
            }
        }
    </script>
    
    <!-- Backup Modal -->
    <div id="backupModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>üíæ Backup Database</h3>
                <button class="close-btn" onclick="closeModal('backupModal')">&times;</button>
            </div>
            
            <div style="margin-bottom: 20px;">
                <p style="color: #666; margin-bottom: 15px;">
                    Create a backup copy of your finance database. The file will be downloaded with a timestamp in the filename.
                </p>
                
                <div style="background: #f0f4ff; padding: 15px; border-radius: 8px; border-left: 4px solid #667eea; margin-bottom: 20px;">
                    <strong>üìù Backup Details:</strong>
                    <ul style="margin: 10px 0 0 20px; color: #666;">
                        <li>Format: SQLite database (.db)</li>
                        <li>Includes: All transactions, accounts, categories, and settings</li>
                        <li>Filename: finance_backup_YYYY-MM-DD_HH-MM-SS.db</li>
                    </ul>
                </div>

                <div id="backupStatus" style="display: none; padding: 15px; border-radius: 8px; margin-bottom: 15px;"></div>
            </div>
            
            <div style="display: flex; gap: 10px;">
                <button onclick="downloadDatabaseBackup()" style="flex: 1;">
                    üíæ Download Backup
                </button>
                <button onclick="closeModal('backupModal')" class="secondary" style="flex: 1;">
                    Cancel
                </button>
            </div>
        </div>
    </div>
</body>
</html>