<!DOCTYPE html>
<html lang="en-GB">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delfin ¬∑ The Tools</title>
    <link rel="icon" href="favicon.ico">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #FFF1E6; 
            --panel: #FEE5D7; 
            --card: #D4B5A0; 
            --border: #D4B5A0;
            --muted: #5F5F5F; 
            --text: #2D2D2D;
            --btn-primary: #6B4D3E;   /* Primary button colour */
            --btn-hover: #5C3F32;     /* Hover state colour */
            --danger: #D65A4A;
            --green: #0e9530; 
            --red: #d52811; 
            --yellow: #f5b700;
        }

        html { height: 100%; scrollbar-gutter: stable both-edges; }
        body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: 'IBM Plex Mono', monospace; }
        * { box-sizing: border-box; }

        header { display: flex; align-items: center; justify-content: space-between; padding: 18px 20px; background: var(--panel); border-bottom: 1px solid var(--border); }
        h1 { font-size: 30px; margin: 0; letter-spacing: 0.2px; font-family: 'Playfair Display', serif; }

        /* Navigation dropdown menu */
        .tools { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        .dropdown { position: relative; }
        .dropdown .btn {
            background: var(--bg); color: var(--text); border: 1px solid var(--border);
            border-radius: 8px; padding: 6px 10px; font-size: 12px; cursor: pointer;
            display: flex; align-items: center; gap: 8px; font-family: 'IBM Plex Sans', sans-serif;
        }
        .dropdown.open .menu { display: block; }
        .dropdown .menu {
            position: absolute; top: 120%; right: 0; min-width: 200px;
            background: #fff; border: 1px solid var(--border); border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1); display: none; padding: 8px; z-index: 20;
        }
        .navItem { 
            width: 100%; text-align: left; padding: 8px 12px; border-radius: 6px; 
            background: transparent; border: none; cursor: pointer; font-family: 'IBM Plex Sans', sans-serif; color: var(--text);
        }
        .navItem:hover { background: var(--bg); }

        .container { margin: 20px auto; max-width: 1600px; padding: 0 20px; }
        .card { background: var(--bg); padding: 25px; border: 1px solid var(--border); border-radius: 10px; }

        /* Tools grid layout and cards */
        .tools-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
        }
        
        .tool-card {
            background: #fff;
            padding: 30px;
            border-radius: 12px;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-align: center;
        }
        
        .tool-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(212, 181, 160, 0.3);
            background: #fbe7dd;
        }
        
        .tool-icon { font-size: 40px; margin-bottom: 15px; }
        .tool-title { font-family: 'Playfair Display', serif; font-size: 20px; font-weight: bold; color: var(--text); margin-bottom: 10px; }
        .tool-description { font-family: 'IBM Plex Sans', sans-serif; font-size: 13px; color: var(--muted); line-height: 1.4; }

        /* Modal dialogs (centred) */
        .modal {
            display: none; position: fixed; z-index: 1000;
            left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(45, 45, 45, 0.4);
            backdrop-filter: blur(2px);
        }
        
        .modal-content {
            background-color: var(--bg);
            padding: 0;
            border-radius: 12px;
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 50px rgba(0,0,0,0.2);
            border: 1px solid var(--border);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            animation: slideUpCentered 0.3s ease;
        }

        .modal-header {
            background: var(--panel); padding: 15px 25px;
            border-bottom: 1px solid var(--border);
            display: flex; justify-content: space-between; align-items: center;
        }
        .modal-header h3 { margin: 0; color: var(--text); font-size: 20px; font-family: 'Playfair Display', serif; }
        .close-btn { background: none; border: none; font-size: 24px; color: var(--muted); cursor: pointer; }
        
        /* List items and rows */
        .item-list { padding: 20px; }
        .item-row {
            display: grid; grid-template-columns: 1fr auto; gap: 10px;
            padding: 12px 15px; background: #fff3ed; border: 0.5px solid var(--border);
            border-radius: 8px; margin-bottom: 8px; align-items: center;
            font-family: 'IBM Plex Sans', sans-serif;
        }
        .item-row:nth-child(even) { background: #fbe7dd; }
        .item-name { font-weight: 600; font-size: 14px; }

        /* Form inputs and controls */
        .form-group { margin-bottom: 18px; padding: 0 25px; }
        label { display: block; margin-bottom: 6px; font-weight: 500; font-size: 13px; color: var(--muted); font-family: 'IBM Plex Sans', sans-serif; }
        input, select, textarea {
            width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 8px;
            background: #fff; font-family: 'IBM Plex Sans', sans-serif; font-size: 14px;
        }
        .search-box { padding: 20px 25px 0 25px; margin-bottom: 10px; }
        
        /* Button styles with updated theme colours */
        button {
            padding: 8px 16px; border-radius: 8px; border: 1px solid var(--border);
            font-weight: 600; cursor: pointer; font-family: 'IBM Plex Sans', sans-serif;
            transition: all 0.2s; background: var(--btn-primary); color: white;
        }
        button:hover { background: var(--btn-hover); transform: translateY(-1px); }
        
        button.secondary { background: transparent; border: 1px solid var(--border) !important; color: var(--muted); }
        button.secondary:hover { background: var(--panel); color: var(--text); }
        
        button.danger { background: var(--danger); color: white; border: none; }
        button.danger:hover { opacity: 0.9; }

        .success-message { background: var(--green); color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none; }
        .error-message { background: var(--red); color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none; }

        @keyframes slideUpCentered { 
            from { transform: translate(-50%, -45%); opacity: 0; } 
            to { transform: translate(-50%, -50%); opacity: 1; } 
        }
        .footer { opacity: 0.7; font-size: 12px; text-align: center; margin: 100px 0 40px 0; font-family: 'Playfair Display', serif; }

        #transactionsTable th { padding: 10px; background: var(--panel); border: 1px solid var(--border); }
        #transactionsTable td { padding: 8px; border: 1px solid var(--border); background: #fff; }

        /* --- IMPORT MODAL STYLES --- */
        .import-table-container {
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.02);
        }

        .import-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .import-table th {
            background: #FFF8F3; /* Un tono m√°s claro que --panel */
            color: var(--muted);
            font-family: 'IBM Plex Sans', sans-serif;
            font-weight: 600;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.8px;
            padding: 12px 10px;
            text-align: left;
            border-bottom: 2px solid var(--border);
            white-space: nowrap;
            position: sticky; 
            top: 0; 
            z-index: 10;
        }

        .import-table td {
            padding: 8px 10px;
            border-bottom: 1px solid #eee;
            vertical-align: middle;
            color: var(--text);
            transition: background 0.2s;
        }

        .import-table tr:last-child td { border-bottom: none; }
        .import-table tr:hover td { background-color: #fafafa; }

        /* Column Specifics */
        .col-skip { width: 40px; text-align: center; }
        .col-date { width: 100px; white-space: nowrap; color: var(--muted); font-size: 12px; }
        .col-desc { max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; font-size: 12px; color: var(--muted); }
        .col-amount { text-align: right; font-family: 'IBM Plex Mono', monospace; font-weight: 600; white-space: nowrap; }
        .col-status { width: 80px; text-align: center; }

        /* Inputs styling inside table */
        .import-input, .import-select, .import-textarea {
            width: 100%;
            padding: 6px 8px;
            font-size: 12px;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            background: #fff;
            font-family: 'IBM Plex Sans', sans-serif;
            color: var(--text);
            transition: all 0.2s;
        }

        .import-select {
            padding-right: 20px;
            background-image: url("data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%235F5F5F%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 8px auto;
            appearance: none;
            -webkit-appearance: none;
        }

        .import-input:focus, .import-select:focus, .import-textarea:focus {
            border-color: var(--btn-primary);
            outline: none;
            box-shadow: 0 0 0 2px rgba(107, 77, 62, 0.1);
        }

        .import-textarea {
            resize: none;
            height: 32px;
            line-height: 1.2;
        }

        /* Badges */
        .badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 4px 8px;
            border-radius: 99px;
            font-size: 10px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .badge-new { background: #E6FFFA; color: #047857; border: 1px solid #B2F5EA; }
        .badge-dup { background: #FFF5F5; color: #C53030; border: 1px solid #FED7D7; }

        /* Checkbox styling */
        .custom-checkbox {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--btn-primary);
        }

        /* Row States */
        tr.duplicate td { background-color: #fffaf0 !important; opacity: 0.8; }
        tr.duplicate:hover td { background-color: #fffaf0; opacity: 1; }
        tr.skipped td { opacity: 0.4; filter: grayscale(100%); background: #f9f9f9; }
        tr.skipped:hover td { opacity: 0.6; }

        /* Compact gap for stacked selects */
        .gap-small { display: flex; flex-direction: column; gap: 4px; }

        /* --- TOAST NOTIFICATIONS --- */
        #toast-container {
            position: fixed;
            top: 25px;
            right: 25px;
            z-index: 9999; /* Por encima de todo, incluidos los modales (z-index 1000) */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .toast {
            min-width: 300px;
            padding: 16px 20px;
            border-radius: 8px;
            color: white;
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 13px;
            font-weight: 500;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            justify-content: space-between;
            animation: slideInToast 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0.98;
            cursor: pointer;
        }

        .toast.success { background-color: var(--green); border-left: 5px solid #065f46; }
        .toast.error { background-color: var(--red); border-left: 5px solid #7f1d1d; }

        @keyframes slideInToast {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes fadeOutToast {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }
    </style>
</head>
<body>
    <header>
        <h1>üê¨ Delfin ¬∑ The Tools</h1>
        <div class="tools">
            <div class="dropdown" id="navDropdown">
                <button class="btn" id="navBtn" onclick="toggleNav()">üìÇ Menu ‚ñæ</button>
                <div class="menu" id="navMenu">
                    <div class="list" style="padding: 6px;">
                        <button class="navItem" onclick="location.href='index.html'">üìä Dashboard</button>
                        <button class="navItem" onclick="location.href='transactions.html'">üßæ Transactions</button>
                        <button class="navItem" onclick="location.href='budget.html'">üìã Budget</button>
                        <button class="navItem" onclick="location.href='loans.html'">üí∞ Loans</button>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <div class="container">
        <div id="successMessage" class="success-message"></div>
        <div id="errorMessage" class="error-message"></div>
        
        <div class="card">
            <div class="tools-grid">
                <div class="tool-card" onclick="openTool('categories')">
                    <div class="tool-icon">üìÅ</div>
                    <div class="tool-title">Categories</div>
                    <div class="tool-description">Manage parent categories and their sub-items.</div>
                </div>
                
                <div class="tool-card" onclick="openTool('accounts')">
                    <div class="tool-icon">üí≥</div>
                    <div class="tool-title">Accounts</div>
                    <div class="tool-description">Manage names, currencies and active status.</div>
                </div>
                
                <div class="tool-card" onclick="openTool('payees')">
                    <div class="tool-icon">üë§</div>
                    <div class="tool-title">Payees</div>
                    <div class="tool-description">Edit payee names and view statistics.</div>
                </div>
                
                <div class="tool-card" onclick="openTool('locations')">
                    <div class="tool-icon">üìç</div>
                    <div class="tool-title">Locations</div>
                    <div class="tool-description">Edit common location names.</div>
                </div>
                
                <div class="tool-card" onclick="openTool('projects')">
                    <div class="tool-icon">üìã</div>
                    <div class="tool-title">Projects</div>
                    <div class="tool-description">Manage your active projects.</div>
                </div>

                <div class="tool-card" onclick="openTool('import')">
                    <div class="tool-icon">üì•</div>
                    <div class="tool-title">Import</div>
                    <div class="tool-description">Import from CSV bank statements.</div>
                </div>

                <div class="tool-card" onclick="openTool('export')">
                    <div class="tool-icon">üì§</div>
                    <div class="tool-title">Export</div>
                    <div class="tool-description">Export your data to CSV format.</div>
                </div>
                
                <div class="tool-card" onclick="openTool('backup')">
                    <div class="tool-icon">üíæ</div>
                    <div class="tool-title">Backup</div>
                    <div class="tool-description">Download a timestamped database backup.</div>
                </div>
            </div>
        </div>
    </div>

    <div id="categoriesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h3>Manage Categories</h3><button class="close-btn" onclick="closeModal('categoriesModal')">&times;</button></div>
            <div class="search-box"><input type="text" id="categorySearch" placeholder="Search categories..." onkeyup="filterCategories()"></div>
            <div class="item-list" id="categoriesList"></div>
        </div>
    </div>
    
    <div id="accountsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h3>Manage Accounts</h3><button class="close-btn" onclick="closeModal('accountsModal')">&times;</button></div>
            <div class="search-box"><input type="text" id="accountSearch" placeholder="Search accounts..." onkeyup="filterAccounts()"></div>
            <div class="item-list" id="accountsList"></div>
        </div>
    </div>
    
    <div id="payeesModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h3>Manage Payees</h3><button class="close-btn" onclick="closeModal('payeesModal')">&times;</button></div>
            <div style="padding: 10px 25px;"><button onclick="detectDuplicatePayees()" style="width: 100%;">üîç Detect Duplicate Payees</button></div>
            <div class="search-box"><input type="text" id="payeeSearch" placeholder="Search payees..." onkeyup="filterPayees()"></div>
            <div class="item-list" id="payeesList"></div>
        </div>
    </div>
    
    <div id="locationsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h3>Manage Locations</h3><button class="close-btn" onclick="closeModal('locationsModal')">&times;</button></div>
            <div class="search-box"><input type="text" id="locationSearch" placeholder="Search locations..." onkeyup="filterLocations()"></div>
            <div class="item-list" id="locationsList"></div>
        </div>
    </div>
    
    <div id="projectsModal" class="modal">
        <div class="modal-content">
            <div class="modal-header"><h3>Manage Projects</h3><button class="close-btn" onclick="closeModal('projectsModal')">&times;</button></div>
            <div class="search-box"><input type="text" id="projectSearch" placeholder="Search projects..." onkeyup="filterProjects()"></div>
            <div class="item-list" id="projectsList"></div>
        </div>
    </div>
    
    <div id="editModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header"><h3 id="editModalTitle">Edit Item</h3><button class="close-btn" onclick="closeModal('editModal')">&times;</button></div>
            <div style="padding: 20px 0;">
                <div class="form-group"><label>Name</label><input type="text" id="editName"></div>
                <div class="form-group" id="editCurrencyGroup" style="display: none;">
                    <label>Currency</label>
                    <select id="editCurrency"><option value="GBP">GBP (¬£)</option><option value="EUR">EUR (‚Ç¨)</option><option value="USD">USD ($)</option></select>
                </div>
                <div class="form-group" id="editParentGroup" style="display: none;"><label>Parent Category</label><input type="text" id="editParent" readonly style="background: #f0f0f0;"></div>
                <div style="display: flex; gap: 10px; padding: 0 25px;">
                    <button onclick="saveEdit()" style="flex: 1;">Save</button>
                    <button onclick="closeModal('editModal')" class="secondary" style="flex: 1;">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <div id="importModal" class="modal">
        <div class="modal-content" style="max-width: 95%;">
            <div class="modal-header"><h3>üì• Import Statements</h3><button class="close-btn" onclick="closeModal('importModal')">&times;</button></div>
            <div style="padding: 25px;">
                <div id="importSuccessMessage" class="success-message"></div>
                <div id="importErrorMessage" class="error-message"></div>
                <div id="uploadSection">
                    <div class="form-group" style="padding: 0; margin-bottom: 20px;"><label>Select Account</label><select id="importAccount" onchange="handleAccountSelection()"></select></div>
                    <div style="border: 2px dashed var(--border); border-radius: 10px; padding: 40px; text-align: center; background: #fff;">
                        <input type="file" id="fileInput" accept=".csv" style="display: none;" onchange="handleFileUpload(event)">
                        <button id="chooseFileBtn" onclick="document.getElementById('fileInput').click()" disabled style="opacity: 0.5; cursor: not-allowed;">Choose CSV File</button>
                        <p id="selectAccountHint" style="margin-top: 10px; font-size: 12px; color: var(--muted);">Please select an account first</p>
                    </div>
                </div>
                <div id="previewSection" style="display: none;">
                    <div style="background: var(--panel); padding: 12px 20px; border-radius: 8px; margin-bottom: 20px; display: flex; justify-content: space-between; align-items: center; border: 1px solid var(--border);">
                        <div style="font-family: 'IBM Plex Sans', sans-serif; font-size: 14px; font-weight: 500;">
                            Found <strong id="totalTransactions">0</strong> transactions
                        </div>
                        <div style="font-size: 12px; display: flex; gap: 15px;">
                            <span class="badge badge-dup">Duplicates: <span id="duplicateCount">0</span></span>
                            <span class="badge badge-new">New: <span id="newCount">0</span></span>
                        </div>
                    </div>

                    <div class="import-table-container" style="max-height: 500px; overflow-y: auto;">
                        <table class="import-table">
                            <thead>
                                <tr>
                                    <th class="col-skip">Skip</th>
                                    <th style="width: 110px;">Date</th>
                                    <th style="width: 150px;">Description</th>
                                    <th style="text-align: right; width: 100px;">Amount</th>
                                    <th style="width: 100px;">Type</th>
                                    <th style="width: 180px;">Payee</th>
                                    <th style="width: 180px;">Category</th>
                                    <th style="width: 120px;">Location / Project</th>
                                    <th>Note</th>
                                    <th class="col-status">Status</th>
                                </tr>
                            </thead>
                            <tbody id="transactionsTableBody"></tbody>
                        </table>
                    </div>

                    <div style="display: flex; gap: 10px; margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
                        <button onclick="importTransactions()" style="flex: 1; height: 44px; font-size: 15px;">‚úÖ Import <span id="importCount">0</span> Items</button>
                        <button onclick="cancelImport()" class="secondary" style="height: 44px;">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="exportModal" class="modal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header"><h3>üì§ Export to CSV</h3><button class="close-btn" onclick="closeModal('exportModal')">&times;</button></div>
            <div style="padding: 20px 0;">
                <div class="form-group"><label>From Date</label><input type="date" id="exportStartDate"></div>
                <div class="form-group"><label>To Date</label><input type="date" id="exportEndDate"></div>
                <div class="form-group"><label>Account</label><select id="exportAccount"></select></div>
                <div class="form-group"><label>Format</label><select id="exportFormat"><option value="standard">Standard</option><option value="detailed">Detailed</option></select></div>
                <div style="padding: 0 25px;"><button onclick="exportToCSV()" style="width: 100%;">Download CSV</button></div>
            </div>
        </div>
    </div>

    <div id="backupModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header"><h3>üíæ Backup Database</h3><button class="close-btn" onclick="closeModal('backupModal')">&times;</button></div>
            <div style="padding: 25px; text-align: center;">
                <div id="backupStatus" style="padding: 15px; border-radius: 8px; margin-bottom: 15px; display: none;"></div>
                <button onclick="downloadDatabaseBackup()" style="width: 100%;">Download Backup (.db)</button>
            </div>
        </div>
    </div>

    <!-- Modals for creating new items during CSV import -->
    <div id="newParentCategoryModal" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header"><h3>New Parent Category</h3><button class="close-btn" onclick="closeModal('newParentCategoryModal')">&times;</button></div>
            <div style="padding: 20px;">
                <label style="display:block; margin-bottom: 5px;">Name</label>
                <input type="text" id="newParentCategoryName" style="width: 100%; padding: 8px; margin-bottom: 15px;">
                <input type="hidden" id="newParentCategoryForIndex">
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeModal('newParentCategoryModal')" style="background: #ccc;">Cancel</button>
                    <button onclick="saveNewParentCategoryForImport()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <div id="newSubcategoryModalImport" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header"><h3>New Subcategory</h3><button class="close-btn" onclick="closeModal('newSubcategoryModalImport')">&times;</button></div>
            <div style="padding: 20px;">
                <label style="display:block; margin-bottom: 5px;">Parent</label>
                <input type="text" id="newSubcategoryParentName" readonly style="width: 100%; padding: 8px; margin-bottom: 15px; background: #f0f0f0;">
                <label style="display:block; margin-bottom: 5px;">Name</label>
                <input type="text" id="newSubcategoryNameImport" style="width: 100%; padding: 8px; margin-bottom: 15px;">
                <input type="hidden" id="newSubcategoryForIndex">
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeModal('newSubcategoryModalImport')" style="background: #ccc;">Cancel</button>
                    <button onclick="saveNewSubcategoryForImport()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <div id="newLocationModalImport" class="modal">
        <div class="modal-content" style="max-width: 400px;">
            <div class="modal-header"><h3>New Location</h3><button class="close-btn" onclick="closeModal('newLocationModalImport')">&times;</button></div>
            <div style="padding: 20px;">
                <label style="display:block; margin-bottom: 5px;">Name</label>
                <input type="text" id="newLocationNameImport" style="width: 100%; padding: 8px; margin-bottom: 15px;">
                <input type="hidden" id="newLocationForIndex">
                <div style="display: flex; gap: 10px; justify-content: flex-end;">
                    <button onclick="closeModal('newLocationModalImport')" style="background: #ccc;">Cancel</button>
                    <button onclick="saveNewLocationForImport()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Confirm/Prompt Modal (replaces browser dialogs which may be blocked) -->
    <div id="customDialogModal" class="modal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h3 id="customDialogTitle">Confirm</h3>
                <button class="close-btn" onclick="closeCustomDialog(false)">&times;</button>
            </div>
            <div style="padding: 20px 25px;">
                <p id="customDialogMessage" style="margin: 0 0 15px 0; font-size: 14px; line-height: 1.5;"></p>
                <input type="text" id="customDialogInput" style="display: none; margin-bottom: 15px;">
            </div>
            <div style="padding: 15px 25px; border-top: 1px solid var(--border); display: flex; gap: 10px; justify-content: flex-end;">
                <button id="customDialogCancelBtn" class="secondary" onclick="closeCustomDialog(false)">Cancel</button>
                <button id="customDialogConfirmBtn" onclick="closeCustomDialog(true)">Confirm</button>
            </div>
        </div>
    </div>

    <div class="footer">¬© Royal Bank of Gonz√°lez. 2025</div>

    <script>
        // Navigation dropdown logic
        function toggleNav() { document.querySelector('#navDropdown').classList.toggle('open'); }
        document.addEventListener('click', (e) => { if (document.querySelector('#navDropdown') && !document.querySelector('#navDropdown').contains(e.target)) document.querySelector('#navDropdown').classList.remove('open'); });

        const API_URL = 'http://localhost:8000';
        
        // Custom dialog system (replaces confirm/prompt which may be blocked)
        let customDialogResolve = null;
        let customDialogIsPrompt = false;
        
        function customConfirm(message, title = 'Confirm', confirmText = 'Confirm', isDanger = false) {
            return new Promise((resolve) => {
                customDialogResolve = resolve;
                customDialogIsPrompt = false;
                document.getElementById('customDialogTitle').textContent = title;
                document.getElementById('customDialogMessage').innerHTML = message.replace(/\n/g, '<br>');
                document.getElementById('customDialogInput').style.display = 'none';
                document.getElementById('customDialogConfirmBtn').textContent = confirmText;
                document.getElementById('customDialogConfirmBtn').style.background = isDanger ? 'var(--danger)' : 'var(--btn-primary)';
                document.getElementById('customDialogModal').style.display = 'block';
            });
        }
        
        function customPrompt(message, title = 'Input', defaultValue = '') {
            return new Promise((resolve) => {
                customDialogResolve = resolve;
                customDialogIsPrompt = true;
                document.getElementById('customDialogTitle').textContent = title;
                document.getElementById('customDialogMessage').innerHTML = message.replace(/\n/g, '<br>');
                const input = document.getElementById('customDialogInput');
                input.style.display = 'block';
                input.value = defaultValue;
                input.focus();
                document.getElementById('customDialogConfirmBtn').textContent = 'OK';
                document.getElementById('customDialogConfirmBtn').style.background = 'var(--btn-primary)';
                document.getElementById('customDialogModal').style.display = 'block';
            });
        }
        
        function closeCustomDialog(confirmed) {
            document.getElementById('customDialogModal').style.display = 'none';
            if (customDialogResolve) {
                if (customDialogIsPrompt) {
                    customDialogResolve(confirmed ? document.getElementById('customDialogInput').value : null);
                } else {
                    customDialogResolve(confirmed);
                }
                customDialogResolve = null;
            }
        }
        
        // Handle Enter key in prompt input
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('customDialogInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') closeCustomDialog(true);
                if (e.key === 'Escape') closeCustomDialog(false);
            });
        });
        
        let allCategories = [];
        let allAccounts = [];
        let allPayees = [];
        let allLocations = [];
        let allProjects = [];
        
        let currentEditItem = null;
        let currentEditType = null;

        // Import variables
        let parsedTransactions = [];
        let existingTransactions = [];
        let payeeSuggestions = {};
        let allAccountsForImport = [];
                
        // Open tool modal
        async function openTool(toolName) {
            switch(toolName) {
                case 'categories':
                    await loadCategories();
                    displayCategories();
                    document.getElementById('categoriesModal').style.display = 'block';
                    break;
                case 'accounts':
                    await loadAccounts();
                    displayAccounts();
                    document.getElementById('accountsModal').style.display = 'block';
                    break;
                case 'payees':
                    await loadPayees();
                    displayPayees();
                    document.getElementById('payeesModal').style.display = 'block';
                    break;
                case 'locations':
                    await loadLocations();
                    displayLocations();
                    document.getElementById('locationsModal').style.display = 'block';
                    break;
                case 'projects':
                    await loadProjects();
                    displayProjects();
                    document.getElementById('projectsModal').style.display = 'block';
                    break;
                case 'import':
                    await loadImportData();
                    document.getElementById('importModal').style.display = 'block';
                    break;
                case 'export':
                    await loadExportData();
                    document.getElementById('exportModal').style.display = 'block';
                    break;
                case 'backup':
                    document.getElementById('backupModal').style.display = 'block';
                    document.getElementById('backupStatus').style.display = 'none';
                    break;
            }
        }
   
        // Close modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        // Toast notification system
        function showToast(message, type = 'success') {
            let container = document.getElementById('toast-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'toast-container';
                document.body.appendChild(container);
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icon = type === 'success' ? '‚úÖ' : '‚ö†Ô∏è';
            
            toast.innerHTML = `
                <div style="display:flex; gap:10px; align-items:center;">
                    <span style="font-size:16px;">${icon}</span>
                    <span>${message.replace(/\n/g, '<br>')}</span>
                </div>
                <span style="font-size:18px; margin-left:15px; opacity:0.6;">&times;</span>
            `;

            toast.onclick = () => removeToast(toast);

            container.appendChild(toast);

            setTimeout(() => removeToast(toast), type === 'error' ? 6000 : 3000);
        }

        function removeToast(toast) {
            toast.style.animation = 'fadeOutToast 0.4s forwards';
            setTimeout(() => {
                if (toast.parentElement) toast.remove();
            }, 400);
        }

        // Legacy function wrappers
        function showSuccess(message) { showToast(message, 'success'); }
        function showError(message) { showToast(message, 'error'); }
        function showImportSuccess(message) { showToast(message, 'success'); }
        function showImportError(message) { showToast(message, 'error'); }
        
        // Load data functions
        async function loadCategories() {
            const response = await fetch(`${API_URL}/categories?limit=1000`);
            allCategories = await response.json();
            
            // Sort alphabetically by parent first, then by name
            allCategories.sort((a, b) => {
                const parentA = a.parent || '';
                const parentB = b.parent || '';
                if (parentA !== parentB) {
                    return parentA.localeCompare(parentB);
                }
                return a.name.localeCompare(b.name);
            });
        }
        
        async function loadAccounts() {
            // Load ALL accounts including closed ones, WITH REAL BALANCES
            const response = await fetch(`${API_URL}/accounts/with-balances?include_closed=true`);
            allAccounts = await response.json();
            
            // Sort: active accounts first, then by name
            allAccounts.sort((a, b) => {
                if (a.is_active !== b.is_active) {
                    return b.is_active - a.is_active;  // Active (1) before closed (0)
                }
                return a.name.localeCompare(b.name);
            });
        }
        
        async function loadPayees() {
            const response = await fetch(`${API_URL}/payees`);
            allPayees = await response.json();
            
            // Sort alphabetically by name
            allPayees.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        async function loadLocations() {
            const response = await fetch(`${API_URL}/locations`);
            allLocations = await response.json();
            
            // Sort alphabetically by name
            allLocations.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        async function loadProjects() {
            const response = await fetch(`${API_URL}/projects`);
            allProjects = await response.json();
            
            // Sort alphabetically by name
            allProjects.sort((a, b) => a.name.localeCompare(b.name));
        }
        
        // Display functions
        function displayCategories(filtered = null) {
            const categories = filtered || allCategories;
            const list = document.getElementById('categoriesList');
            
            // Group categories by parent
            const grouped = {};
            const allParentNames = new Set();
            
            categories.forEach(cat => {
                if (cat.parent) {
                    allParentNames.add(cat.parent);
                    if (!grouped[cat.parent]) {
                        grouped[cat.parent] = [];
                    }
                    grouped[cat.parent].push(cat);
                }
            });
            
            // Find standalone parent categories (parents without children)
            const standaloneParents = categories.filter(cat => 
                !cat.parent && !allParentNames.has(cat.name)
            );
            
            // Add standalone parents to grouped (with empty array)
            standaloneParents.forEach(cat => {
                grouped[cat.name] = [];
            });
            
            // Sort all parent names alphabetically
            const sortedParents = Object.keys(grouped).sort((a, b) => a.localeCompare(b));
            
            // Build HTML
            let html = '';
            
            sortedParents.forEach(parent => {
                const subcategories = grouped[parent].sort((a, b) => a.name.localeCompare(b.name));
                
                // Header with parent name and edit button
                if (subcategories.length > 0) {
                    html += `
                        <div style="margin-bottom: 25px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; font-size: 18px; font-weight: bold; color: #667eea; margin-bottom: 10px; padding: 10px; background: #f0f4ff; border-radius: 8px;">
                                <span>üìÅ ${parent}</span>
                                <button onclick="editParentCategory('${parent.replace(/'/g, "\\'")}', ${JSON.stringify(subcategories.map(c => c.id))})" style="padding: 6px 12px; font-size: 13px;">‚úèÔ∏è Edit Parent</button>
                            </div>
                    `;
                    
                    subcategories.forEach((cat, index) => {
                        const isLast = index === subcategories.length - 1;
                        const connector = isLast ? '‚îî‚îÄ' : '‚îú‚îÄ';
                        
                        html += `
                            <div class="item-row" style="margin-left: 20px; margin-bottom: 8px;">
                                <div class="item-info">
                                    <div class="item-name">
                                        <span style="color: #999; margin-right: 8px;">${connector}</span>
                                        ${cat.name}
                                    </div>
                                </div>
                                <div class="item-actions">
                                    <button onclick="editItem('category', ${cat.id})">‚úèÔ∏è Edit</button>
                                    <button onclick="deleteCategory(${cat.id}, '${cat.name.replace(/'/g, "\\'")}', '${(cat.parent || '').replace(/'/g, "\\'")}')" style="background: #f87171; color: white;">üóëÔ∏è</button>
                                </div>
                            </div>
                        `;
                    });
                    
                    html += '</div>';
                } else {
                    // Standalone parent (no children)
                    const standaloneCategory = standaloneParents.find(c => c.name === parent);
                    html += `
                        <div style="margin-bottom: 25px;">
                            <div class="item-row">
                                <div class="item-info">
                                    <div class="item-name">üìÅ ${parent}</div>
                                    <div class="item-meta">Parent Category (no subcategories)</div>
                                </div>
                                <div class="item-actions">
                                    <button onclick="editItem('category', ${standaloneCategory.id})">‚úèÔ∏è Edit</button>
                                    <button onclick="deleteCategory(${standaloneCategory.id}, '${parent.replace(/'/g, "\\'")}', null)" style="background: #f87171; color: white;">üóëÔ∏è</button>
                                </div>
                            </div>
                        </div>
                    `;
                }
            });
            
            if (html === '') {
                html = '<p style="text-align: center; color: #666; padding: 20px;">No categories found</p>';
            }
            
            list.innerHTML = html;
        }
        
        function displayAccounts(filtered = null) {
            const accounts = filtered || allAccounts;
            const list = document.getElementById('accountsList');
            
            list.innerHTML = accounts.map(acc => {
                const status_badge = acc.is_active === 1 
                    ? '<span style="background: #4ade80; color: white; padding: 3px 8px; border-radius: 5px; font-size: 11px; margin-left: 10px;">Active</span>' 
                    : '<span style="background: #f87171; color: white; padding: 3px 8px; border-radius: 5px; font-size: 11px; margin-left: 10px;">Closed</span>';
                
                const action_button = acc.is_active === 1
                    ? `<button onclick="closeAccount(${acc.id}, '${acc.name.replace(/'/g, "\\'")}', ${acc.current_balance})" style="background: #f87171; color: white;">üîí Close Account</button>`
                    : `<button onclick="openAccount(${acc.id}, '${acc.name.replace(/'/g, "\\'")}')">üîì Open Account</button>`;
                
                return `
                    <div class="item-row" style="${acc.is_active === 0 ? 'opacity: 0.6;' : ''}">
                        <div class="item-info">
                            <div class="item-name">
                                ${acc.name}
                                ${status_badge}
                            </div>
                            <div class="item-meta">Currency: ${acc.currency} | Type: ${acc.type || 'Regular'} | Balance: ${acc.current_balance.toFixed(2)}</div>
                        </div>
                        <div class="item-actions">
                            <button onclick="editItem('account', ${acc.id})">‚úèÔ∏è Edit</button>
                            ${action_button}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function displayPayees(filtered = null) {
            const payees = filtered || allPayees;
            const list = document.getElementById('payeesList');
            
            list.innerHTML = payees.map(payee => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${payee.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('payee', ${payee.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        function displayLocations(filtered = null) {
            const locations = (filtered || allLocations).filter(l => l.name !== 'Transfer In' && l.name !== 'Transfer Out');
            const list = document.getElementById('locationsList');
            
            list.innerHTML = locations.map(loc => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${loc.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('location', ${loc.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        function displayProjects(filtered = null) {
            const projects = filtered || allProjects;
            const list = document.getElementById('projectsList');
            
            list.innerHTML = projects.map(proj => `
                <div class="item-row">
                    <div class="item-info">
                        <div class="item-name">${proj.name}</div>
                    </div>
                    <div class="item-actions">
                        <button onclick="editItem('project', ${proj.id})">‚úèÔ∏è Edit</button>
                    </div>
                </div>
            `).join('');
        }
        
        // Filter functions
        function filterCategories() {
            const search = document.getElementById('categorySearch').value.toLowerCase();
            const filtered = allCategories.filter(cat => 
                cat.name.toLowerCase().includes(search) || 
                (cat.parent && cat.parent.toLowerCase().includes(search))
            );
            displayCategories(filtered);
        }
        
        function filterAccounts() {
            const search = document.getElementById('accountSearch').value.toLowerCase();
            const filtered = allAccounts.filter(acc => 
                acc.name.toLowerCase().includes(search)
            );
            displayAccounts(filtered);
        }
        
        function filterPayees() {
            const search = document.getElementById('payeeSearch').value.toLowerCase();
            const filtered = allPayees.filter(payee => 
                payee.name.toLowerCase().includes(search)
            );
            displayPayees(filtered);
        }
        
        function filterLocations() {
            const search = document.getElementById('locationSearch').value.toLowerCase();
            const filtered = allLocations.filter(loc => 
                loc.name.toLowerCase().includes(search)
            );
            displayLocations(filtered);
        }
        
        function filterProjects() {
            const search = document.getElementById('projectSearch').value.toLowerCase();
            const filtered = allProjects.filter(proj => 
                proj.name.toLowerCase().includes(search)
            );
            displayProjects(filtered);
        }
        
        // Edit item
        async function deleteCategory(id, name, parent) {
            const categoryType = parent ? 'subcategory' : 'parent category';
            const fullName = parent ? `${parent} ‚Üí ${name}` : name;
            
            // First confirmation
            const confirmed = await customConfirm(
                `Are you sure you want to delete the ${categoryType} "${fullName}"?\n\nThis action cannot be undone.`,
                'Delete Category',
                'Delete',
                true
            );
            if (!confirmed) return;
            
            // Second confirmation with typed name
            const typedName = await customPrompt(
                `To confirm deletion, please type the category name exactly:\n\n<strong>${name}</strong>`,
                'Confirm Deletion'
            );
            if (typedName !== name) {
                if (typedName !== null) {
                    showError('Category name does not match. Deletion cancelled.');
                }
                return;
            }
            
            try {
                const response = await fetch(`${API_URL}/categories/${id}`, {
                    method: 'DELETE'
                });
                
                if (response.ok) {
                    showSuccess(`Category "${name}" deleted successfully`);
                    await loadCategories();
                    displayCategories();
                } else {
                    const error = await response.json();
                    showError(error.detail || 'Failed to delete category');
                }
            } catch (error) {
                showError('Failed to delete category: ' + error.message);
            }
        }

        function editItem(type, id) {
            currentEditType = type;
            let item;
            
            switch(type) {
                case 'category':
                    item = allCategories.find(c => c.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Category';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = item.parent ? 'block' : 'none';
                    if (item.parent) {
                        document.getElementById('editParent').value = item.parent;
                    }
                    break;
                case 'account':
                    item = allAccounts.find(a => a.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Account';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'block';
                    document.getElementById('editCurrency').value = item.currency;
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
                case 'payee':
                    item = allPayees.find(p => p.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Payee';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
                case 'location':
                    item = allLocations.find(l => l.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Location';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
                case 'project':
                    item = allProjects.find(p => p.id === id);
                    document.getElementById('editModalTitle').textContent = 'Edit Project';
                    document.getElementById('editName').value = item.name;
                    document.getElementById('editCurrencyGroup').style.display = 'none';
                    document.getElementById('editParentGroup').style.display = 'none';
                    break;
            }
            
            currentEditItem = item;
            document.getElementById('editModal').style.display = 'block';
        }

        // Edit parent category name
        async function editParentCategory(oldParentName, subcategoryIds) {
            const newParentName = await customPrompt(`Edit parent category name:`, 'Edit Parent Category', oldParentName);
            
            if (!newParentName || newParentName.trim() === '') {
                return;
            }
            
            if (newParentName.trim() === oldParentName) {
                return; // No change
            }
            
            try {
                // Update all subcategories with the new parent name
                const updatePromises = subcategoryIds.map(async (id) => {
                    const category = allCategories.find(c => c.id === id);
                    
                    const response = await fetch(`${API_URL}/categories/${id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: category.name,
                            parent: newParentName.trim(),
                            type: category.type
                        })
                    });
                    
                    return response.ok;
                });
                
                const results = await Promise.all(updatePromises);
                
                if (results.every(r => r)) {
                    showSuccess('Parent category renamed successfully!');
                    await loadCategories();
                    displayCategories();
                } else {
                    showError('Some categories failed to update');
                }
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }
        
        // Save edit
        async function saveEdit() {
            const newName = document.getElementById('editName').value.trim();
            
            if (!newName) {
                showError('Name cannot be empty');
                return;
            }
            
            try {
                let endpoint, body;
                
                switch(currentEditType) {
                    case 'category':
                        endpoint = `${API_URL}/categories/${currentEditItem.id}`;
                        body = {
                            name: newName,
                            parent: currentEditItem.parent,
                            type: currentEditItem.type
                        };
                        break;
                    case 'account':
                        endpoint = `${API_URL}/accounts/${currentEditItem.id}`;
                        body = {
                            name: newName,
                            currency: document.getElementById('editCurrency').value,
                            type: currentEditItem.type,
                            initial_balance: currentEditItem.initial_balance
                        };
                        break;
                    case 'payee':
                        endpoint = `${API_URL}/payees/${currentEditItem.id}`;
                        body = { name: newName };
                        break;
                    case 'location':
                        endpoint = `${API_URL}/locations/${currentEditItem.id}`;
                        body = { name: newName };
                        break;
                    case 'project':
                        endpoint = `${API_URL}/projects/${currentEditItem.id}`;
                        body = { name: newName };
                        break;
                }
                
                const response = await fetch(endpoint, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });
                
                if (response.ok) {
                    showSuccess('Item updated successfully!');
                    closeModal('editModal');
                    
                    // Reload the appropriate list
                    switch(currentEditType) {
                        case 'category':
                            await loadCategories();
                            displayCategories();
                            break;
                        case 'account':
                            await loadAccounts();
                            displayAccounts();
                            break;
                        case 'payee':
                            await loadPayees();
                            displayPayees();
                            break;
                        case 'location':
                            await loadLocations();
                            displayLocations();
                            break;
                        case 'project':
                            await loadProjects();
                            displayProjects();
                            break;
                    }
                } else {
                    showError('Failed to update item');
                }
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }

        // Close an account
        async function closeAccount(account_id, account_name, current_balance) {
            // Check for non-zero balance (accounting for floating point errors)
            if (Math.abs(current_balance) > 0.01) {
                showError(`Cannot close account "${account_name}" with non-zero balance: ${current_balance.toFixed(2)}`);
                return;
            }
            
            const confirmed = await customConfirm(
                `Are you sure you want to close the account "${account_name}"?\n\nClosed accounts will not appear in dropdowns or the dashboard, but all historical data will be preserved.`,
                'Close Account',
                'Close Account'
            );
            if (!confirmed) return;
            
            try {
                const response = await fetch(`${API_URL}/accounts/${account_id}/close`, {
                    method: 'PATCH'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showSuccess(result.message);
                    await loadAccounts();
                    displayAccounts();
                } else {
                    const error = await response.json();
                    showError(error.detail || 'Failed to close account');
                }
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }

        // Reopen an account
        async function openAccount(account_id, account_name) {
            const confirmed = await customConfirm(
                `Are you sure you want to reopen the account "${account_name}"?`,
                'Reopen Account',
                'Reopen'
            );
            if (!confirmed) return;
            
            try {
                const response = await fetch(`${API_URL}/accounts/${account_id}/open`, {
                    method: 'PATCH'
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showSuccess(result.message);
                    await loadAccounts();
                    displayAccounts();
                } else {
                    const error = await response.json();
                    showError(error.detail || 'Failed to open account');
                }
            } catch (error) {
                showError('Error: ' + error.message);
            }
        }
        

        


        
        // Close modal when clicking outside
        window.onclick = function(event) {
            if (event.target.classList.contains('modal')) {
                event.target.style.display = 'none';
            }
        }

        // Load data needed for import
        async function loadImportData() {
            try {
                // Load accounts for import selection
                const accountsResponse = await fetch(`${API_URL}/accounts`);
                allAccountsForImport = await accountsResponse.json();
                
                const importAccountSelect = document.getElementById('importAccount');
                importAccountSelect.innerHTML = '<option value="">Select account...</option>';
                allAccountsForImport.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = `${account.name} (${account.currency})`;
                    importAccountSelect.appendChild(option);
                });
                
                // Load payees
                const payeesResponse = await fetch(`${API_URL}/payees`);
                allPayees = await payeesResponse.json();
                
                // Load categories
                await loadCategories();
                
                // Load locations
                const locationsResponse = await fetch(`${API_URL}/locations`);
                allLocations = await locationsResponse.json();
                
                // Load projects
                const projectsResponse = await fetch(`${API_URL}/projects`);
                allProjects = await projectsResponse.json();
                
            } catch (error) {
                console.error('Error loading import data:', error);
                showImportError('Failed to load data for import');
            }
        }

        // Handle account selection - enable/disable file upload button
        function handleAccountSelection() {
            const accountId = document.getElementById('importAccount').value;
            const fileBtn = document.getElementById('chooseFileBtn');
            const hint = document.getElementById('selectAccountHint');
            
            if (accountId) {
                fileBtn.disabled = false;
                fileBtn.style.opacity = '1';
                fileBtn.style.cursor = 'pointer';
                hint.style.display = 'none';
            } else {
                fileBtn.disabled = true;
                fileBtn.style.opacity = '0.5';
                fileBtn.style.cursor = 'not-allowed';
                hint.style.display = 'block';
            }
        }

        // Handle file upload
        async function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const accountId = document.getElementById('importAccount').value;
            if (!accountId) {
                showImportError('Please select an account first');
                event.target.value = '';
                return;
            }
            
            try {
                if (file.name.toLowerCase().endsWith('.csv')) {
                    await parseCSV(file, accountId);
                } else {
                    showImportError('Unsupported file format');
                    event.target.value = '';
                    return;
                }
                
                // Show preview section
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('previewSection').style.display = 'block';
                
                displayTransactionsPreview();
                
            } catch (error) {
                console.error('Error processing file:', error);
                // Show detailed error message
                showError('Error processing file: ' + error.message + '\n\nCheck browser console (F12) for more details');
                event.target.value = '';
                
                // Also log the full error to console
                console.error('Full error details:', error);
                console.error('Error stack:', error.stack);
            }
        }

        // Parse CSV file
        async function parseCSV(file, accountId) {
            console.log('Starting CSV parse for file:', file.name);
            
            const text = await file.text();
            console.log('File text length:', text.length);
            
            const lines = text.split('\n');
            console.log('Total lines:', lines.length);
            
            if (lines.length < 2) {
                throw new Error('CSV file is empty or invalid');
            }
            
            // Get headers
            const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
            console.log('Headers found:', headers);
            
            // Detect bank type and parse accordingly
            if (headers.includes('Transaction ID') && headers.includes('Emoji')) {
                console.log('Detected format: Monzo');
                await parseMonzoCSV(lines, headers, accountId);
            } else if (headers.some(h => h.toLowerCase().includes('transaction date')) && 
                    headers.some(h => h.toLowerCase().includes('transaction description')) && 
                    headers.some(h => h.toLowerCase().includes('debit amount'))) {
                console.log('Detected format: Bank of Scotland');
                await parseBankOfScotlandCSV(lines, headers, accountId);
            } else if (headers.some(h => h.toLowerCase() === 'date') &&
                    headers.some(h => h.toLowerCase() === 'time') &&
                    headers.some(h => h.toLowerCase() === 'gross') &&
                    headers.some(h => h.toLowerCase() === 'fee') &&
                    headers.some(h => h.toLowerCase() === 'transaction id')) {
                console.log('Detected format: PayPal');
                await parsePayPalCSV(lines, headers, accountId);
            } else {
                console.log('Detected format: Generic');
                await parseGenericCSV(lines, headers, accountId);
            }
            
            console.log('Parsed transactions count:', parsedTransactions.length);
        }

        // Parse Monzo CSV format
        async function parseMonzoCSV(lines, headers, accountId) {
            parsedTransactions = [];
            
            // Find column indices
            const dateIdx = headers.indexOf('Date');
            const timeIdx = headers.indexOf('Time');
            const typeIdx = headers.indexOf('Type');
            const nameIdx = headers.indexOf('Name');
            const descriptionIdx = headers.indexOf('Description');
            const amountIdx = headers.indexOf('Amount');
            const categoryIdx = headers.indexOf('Category');
            const notesIdx = headers.indexOf('Notes and #tags');
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const values = parseCSVLine(line);
                
                if (values.length < headers.length) continue;
                
                const dateStr = values[dateIdx];
                const timeStr = values[timeIdx];
                const type = values[typeIdx];
                const name = values[nameIdx];
                const descriptionCol = values[descriptionIdx];
                const amount = parseFloat(values[amountIdx]);
                const note = values[notesIdx];
                
                if (!dateStr || isNaN(amount)) continue;
                
                // Combine Type, Name and Description
                let description = '';
                if (type && name) {
                    description = `${type} - ${name}`;
                } else {
                    description = name || type || '';
                }
                
                // Add Description column in parentheses if available
                if (descriptionCol && descriptionCol.trim() !== '') {
                    description += ` (${descriptionCol})`;
                }
                
                // Parse date - Monzo format is DD/MM/YYYY
                let date;
                try {
                    const dateParts = dateStr.split('/');
                    if (dateParts.length === 3) {
                        const day = dateParts[0].padStart(2, '0');
                        const month = dateParts[1].padStart(2, '0');
                        const year = dateParts[2];
                        
                        // Parse time - format is HH:MM:SS
                        let time = '12:00:00';
                        if (timeStr) {
                            time = timeStr;
                        }
                        
                        // Create ISO format: YYYY-MM-DDTHH:MM:SS
                        const datetime = `${year}-${month}-${day}T${time}`;
                        
                        parsedTransactions.push({
                            date: datetime,
                            description: description,
                            amount: amount,
                            note: note,
                            account_id: parseInt(accountId),
                            isDuplicate: false,
                            type: 'transaction',
                            payee_id: null,
                            category_id: null,
                            location_id: null,
                            project_id: null
                        });
                    }
                } catch (e) {
                    console.error('Error parsing date:', dateStr, e);
                    continue;
                }
            }
            
            // Check for duplicates
            await checkDuplicates();
        }

        // Try to auto-suggest payee based on description
        function autoSuggestPayee(description, index) {
            if (!description) return;
            
            const descLower = description.toLowerCase();
            
            // Check if we already have a suggestion for this exact description
            if (payeeSuggestions[description]) {
                const payeeInput = document.getElementById(`payee_${index}`);
                payeeInput.value = payeeSuggestions[description];
                handlePayeeChange(index);
                return;
            }
            
            // Try to find a matching payee by name similarity
            for (const payee of allPayees) {
                const payeeLower = payee.name.toLowerCase();
                
                // Check if payee name is contained in description
                if (descLower.includes(payeeLower)) {
                    const payeeInput = document.getElementById(`payee_${index}`);
                    payeeInput.value = payee.name;
                    payeeSuggestions[description] = payee.name;
                    handlePayeeChange(index);
                    return;
                }
                
                // Check if description is contained in payee name
                if (payeeLower.includes(descLower)) {
                    const payeeInput = document.getElementById(`payee_${index}`);
                    payeeInput.value = payee.name;
                    payeeSuggestions[description] = payee.name;
                    handlePayeeChange(index);
                    return;
                }
            }
            
            // Try fuzzy matching with existing payees (check first words)
            const descWords = descLower.split(/[\s\-_]+/).filter(w => w.length > 2);
            
            for (const payee of allPayees) {
                const payeeWords = payee.name.toLowerCase().split(/[\s\-_]+/);
                
                // If any significant word matches
                for (const descWord of descWords) {
                    for (const payeeWord of payeeWords) {
                        if (descWord.includes(payeeWord) || payeeWord.includes(descWord)) {
                            const payeeInput = document.getElementById(`payee_${index}`);
                            payeeInput.value = payee.name;
                            payeeSuggestions[description] = payee.name;
                            handlePayeeChange(index);
                            return;
                        }
                    }
                }
            }
        }

        // Parse a CSV line handling quoted values
        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            values.push(current.trim());
            return values;
        }

        // Check for duplicate transactions using batch endpoint (much faster)
        async function checkDuplicates() {
            console.log('=== Starting batch duplicate check ===');
            console.log(`Total transactions to check: ${parsedTransactions.length}`);
            
            if (parsedTransactions.length === 0) return;
            
            try {
                // Prepare batch request data
                const checkData = parsedTransactions.map(trans => ({
                    date: trans.date,
                    amount: trans.amount,
                    account_id: trans.account_id
                }));
                
                console.log('Sending batch request for', checkData.length, 'transactions');
                
                const response = await fetch(`${API_URL}/transactions/check-duplicates-batch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(checkData)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    // Apply results to each transaction
                    result.duplicates.forEach((isDuplicate, index) => {
                        parsedTransactions[index].isDuplicate = isDuplicate;
                    });
                    
                    const duplicateCount = result.duplicates.filter(d => d).length;
                    console.log(`=== Batch duplicate check complete ===`);
                    console.log(`Found ${duplicateCount} duplicates out of ${parsedTransactions.length} transactions`);
                } else {
                    console.error('Batch duplicate check failed, falling back to individual checks');
                    // Fallback: mark all as non-duplicate rather than slow individual checks
                    parsedTransactions.forEach(t => t.isDuplicate = false);
                }
            } catch (error) {
                console.error('Error in batch duplicate check:', error);
                // Fallback: mark all as non-duplicate
                parsedTransactions.forEach(t => t.isDuplicate = false);
            }
        }

        // Cancel import
        function cancelImport() {
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('previewSection').style.display = 'none';
            document.getElementById('fileInput').value = '';
            parsedTransactions = [];
            payeeSuggestions = {};
        }

        // Display transactions preview table
        function displayTransactionsPreview() {
            const tbody = document.getElementById('transactionsTableBody');
            tbody.innerHTML = '';
            
            let duplicateCount = 0;
            let newCount = 0;
            
            parsedTransactions.forEach((trans, index) => {
                if (trans.isDuplicate) {
                    duplicateCount++;
                } else {
                    newCount++;
                }
                
                const row = document.createElement('tr');
                if (trans.isDuplicate) row.classList.add('duplicate');
                if (trans.skip) row.classList.add('skipped');
                
                // Date formatting
                const dateObj = new Date(trans.date);
                const dateStr = dateObj.toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit' });
                const timeStr = dateObj.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });

                row.innerHTML = `
                    <td class="col-skip">
                        <input type="checkbox" id="skip_${index}" class="custom-checkbox" onchange="handleSkipChange(${index})" ${trans.skip ? 'checked' : ''}>
                    </td>
                    <td class="col-date">
                        <div>${dateStr}</div>
                        <div style="font-size: 10px; opacity: 0.7;">${timeStr}</div>
                    </td>
                    <td class="col-desc" title="${trans.description || ''}">
                        ${trans.description || '-'}
                    </td>
                    <td class="col-amount" style="color: ${trans.amount < 0 ? 'var(--red)' : 'var(--green)'};">
                        ¬£${Math.abs(trans.amount).toFixed(2)}
                    </td>
                    <td>
                        <select id="type_${index}" class="import-select" onchange="handleTypeChange(${index})">
                            <option value="transaction" ${trans.type === 'transaction' ? 'selected' : ''}>Transac.</option>
                            <option value="transfer" ${trans.type === 'transfer' ? 'selected' : ''}>Transfer</option>
                        </select>
                    </td>
                    <td>
                        <div id="payee_container_${index}" class="gap-small" style="display: ${trans.type === 'transfer' ? 'none' : 'flex'};">
                            <input list="payees_${index}" id="payee_${index}" 
                                class="import-input"
                                placeholder="Payee..." 
                                onchange="handlePayeeChange(${index})">
                            <datalist id="payees_${index}">
                                ${allPayees.map(p => `<option value="${p.name}">`).join('')}
                            </datalist>
                        </div>

                        <select id="account_${index}" class="import-select" style="display: ${trans.type === 'transfer' ? 'block' : 'none'};">
                            <option value="">Select account...</option>
                            ${allAccountsForImport.map(acc => `<option value="${acc.id}">${acc.name}</option>`).join('')}
                        </select>
                    </td>
                    <td>
                        <div class="gap-small">
                            <select id="parentCategory_${index}" class="import-select" onchange="handleParentCategoryChange(${index})" ${trans.type === 'transfer' ? 'disabled' : ''}>
                                <option value="">Parent...</option>
                                ${getUniqueParents().map(p => `<option value="${p}">${p}</option>`).join('')}
                                <option value="__NEW__" style="color:#667eea;font-weight:bold">‚ûï Add new...</option>
                            </select>
                            <select id="category_${index}" class="import-select" onchange="handleSubcategoryChange(${index})" disabled>
                                <option value="">Subcategory...</option>
                            </select>
                        </div>
                    </td>
                    <td>
                        <div class="gap-small">
                            <select id="location_${index}" class="import-select" onchange="handleLocationChange(${index})" ${trans.type === 'transfer' ? 'disabled' : ''}>
                                <option value="">Loc...</option>
                                ${allLocations.map(l => `<option value="${l.id}">${l.name}</option>`).join('')}
                                <option value="__NEW__" style="color:#667eea;font-weight:bold">‚ûï Add...</option>
                            </select>
                            <select id="project_${index}" class="import-select" ${trans.type === 'transfer' ? 'disabled' : ''}>
                                <option value="">Proj...</option>
                                ${allProjects.map(p => `<option value="${p.id}">${p.name}</option>`).join('')}
                            </select>
                        </div>
                    </td>
                    <td>
                        <textarea id="note_${index}" class="import-textarea"
                                placeholder="Note..."
                                onchange="parsedTransactions[${index}].note = this.value">${trans.note || ''}</textarea>
                    </td>
                    <td class="col-status">
                        ${trans.isDuplicate ? 
                            '<span class="badge badge-dup">Dup</span>' : 
                            '<span class="badge badge-new">New</span>'}
                    </td>
                `;
                
                tbody.appendChild(row);

                // Auto-suggest payee for non-duplicate transactions
                if (!trans.isDuplicate && trans.type === 'transaction') {
                    setTimeout(() => autoSuggestPayee(trans.description, index), 10);
                }
            });
            
            // Update counts
            document.getElementById('totalTransactions').textContent = parsedTransactions.length;
            document.getElementById('duplicateCount').textContent = duplicateCount;
            document.getElementById('newCount').textContent = newCount;
            document.getElementById('importCount').textContent = newCount;
        }

        // Get unique parent categories
        function getUniqueParents() {
            const parents = new Set();
            allCategories.forEach(cat => {
                if (cat.parent) {
                    parents.add(cat.parent);
                }
            });
            return Array.from(parents).sort();
        }

        // Handle transaction type change (Transaction vs Transfer)
        function handleTypeChange(index) {
            const type = document.getElementById(`type_${index}`).value;
            const payeeContainer = document.getElementById(`payee_container_${index}`) || document.getElementById(`payee_${index}`);
            const accountSelect = document.getElementById(`account_${index}`);
            const categoryParent = document.getElementById(`parentCategory_${index}`);
            const categorySelect = document.getElementById(`category_${index}`);
            const locationSelect = document.getElementById(`location_${index}`);
            const projectSelect = document.getElementById(`project_${index}`);
            
            if (type === 'transfer') {
                if(payeeContainer) payeeContainer.style.display = 'none';
                accountSelect.style.display = 'block';
                categoryParent.disabled = true;
                categorySelect.disabled = true;
                locationSelect.disabled = true;
                projectSelect.disabled = true;
                
                parsedTransactions[index].type = 'transfer';
                accountSelect.onchange = () => checkCurrencyDifference(index);
                
            } else {
                if(payeeContainer) payeeContainer.style.display = 'flex';
                accountSelect.style.display = 'none';
                categoryParent.disabled = false;
                locationSelect.disabled = false;
                projectSelect.disabled = false;
                
                parsedTransactions[index].type = 'transaction';
                
                const existingConversion = document.getElementById(`currencyConversion_${index}`);
                if (existingConversion) existingConversion.remove();
            }
        }

        function handleSkipChange(index) {
            const skipCheckbox = document.getElementById(`skip_${index}`);
            const row = skipCheckbox.closest('tr');
            
            parsedTransactions[index].skip = skipCheckbox.checked;
            
            if (skipCheckbox.checked) {
                row.classList.add('skipped');
            } else {
                row.classList.remove('skipped');
            }
            
            updateImportCounts();
        }

        // Check if currencies are different and show conversion field
        function checkCurrencyDifference(index) {
            const trans = parsedTransactions[index];
            const toAccountId = document.getElementById(`account_${index}`).value;
            
            if (!toAccountId) return;
            
            // Get currencies
            const fromAccount = allAccountsForImport.find(a => a.id === trans.account_id);
            const toAccount = allAccountsForImport.find(a => a.id === parseInt(toAccountId));
            
            const td = document.getElementById(`account_${index}`).parentElement;
            
            // Remove existing conversion field if any
            const existingConversion = document.getElementById(`currencyConversion_${index}`);
            if (existingConversion) {
                existingConversion.remove();
            }
            
            if (fromAccount.currency !== toAccount.currency) {
                // Different currencies - show conversion field
                const conversionDiv = document.createElement('div');
                conversionDiv.id = `currencyConversion_${index}`;
                conversionDiv.style.marginTop = '8px';
                
                // Determine the correct message based on transaction direction
                let fromCurrency, toCurrency, fromAmountDisplay, toAmountLabel;
                
                if (trans.amount < 0) {
                    // Money leaving this account (CSV account)
                    fromCurrency = fromAccount.currency;
                    toCurrency = toAccount.currency;
                    fromAmountDisplay = `${fromCurrency} ${Math.abs(trans.amount).toFixed(2)}`;
                    toAmountLabel = `Amount received in ${toCurrency}:`;
                } else {
                    // Money entering this account (CSV account)
                    // The selected account is the source
                    fromCurrency = toAccount.currency;
                    toCurrency = fromAccount.currency;
                    fromAmountDisplay = `${toCurrency} ${Math.abs(trans.amount).toFixed(2)} (received)`;
                    toAmountLabel = `Amount sent from ${fromCurrency}:`;
                }
                
                conversionDiv.innerHTML = `
                    <div style="background: #fff3cd; padding: 8px; border-radius: 4px; border: 1px solid #ffc107;">
                        <div style="font-size: 11px; color: #856404; margin-bottom: 4px;">
                            <strong>Currency conversion required</strong>
                        </div>
                        <div style="font-size: 12px; margin-bottom: 4px;">
                            ${trans.amount < 0 ? 'Sending' : 'Receiving'}: ${fromAmountDisplay}
                        </div>
                        <label style="font-size: 12px; display: block; margin-bottom: 4px;">
                            ${toAmountLabel}
                        </label>
                        <input type="number" 
                            id="convertedAmount_${index}" 
                            step="0.01" 
                            placeholder="Enter amount in ${trans.amount < 0 ? toCurrency : fromCurrency}"
                            style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;"
                            onchange="parsedTransactions[${index}].convertedAmount = parseFloat(this.value)">
                    </div>
                `;
                td.appendChild(conversionDiv);
            }
        }

        // Handle payee change
        async function handlePayeeChange(index, skipSimilarApplication = false) {
            const payeeInput = document.getElementById(`payee_${index}`);
            const payeeName = payeeInput.value.trim();
            
            if (!payeeName) return;
            
            // Find payee
            let payee = allPayees.find(p => p.name.toLowerCase() === payeeName.toLowerCase());
            
            if (payee) {
                parsedTransactions[index].payee_id = payee.id;
                
                // Use pre-calculated most common values
                autoFillFromPayeeStats(index, payee);
                
                // Store suggestion for similar descriptions
                payeeSuggestions[parsedTransactions[index].description] = payeeName;
                
                // Apply suggestion to other transactions with same description
                // Only if this is not already a cascaded call
                if (!skipSimilarApplication) {
                    applySuggestionToSimilar(index);
                }
            } else {
                parsedTransactions[index].payee_id = null;
            }
        }

        // Auto-fill fields based on pre-calculated payee statistics
        function autoFillFromPayeeStats(index, payee) {
            try {
                // Use the pre-calculated most common category
                if (payee.most_common_category_id) {
                    const category = allCategories.find(c => c.id === payee.most_common_category_id);
                    if (category && category.parent) {
                        document.getElementById(`parentCategory_${index}`).value = category.parent;
                        handleParentCategoryChange(index);
                        setTimeout(() => {
                            document.getElementById(`category_${index}`).value = payee.most_common_category_id;
                            parsedTransactions[index].category_id = payee.most_common_category_id;
                        }, 50);
                    }
                }
                
                // Use the pre-calculated most common location
                if (payee.most_common_location_id) {
                    document.getElementById(`location_${index}`).value = payee.most_common_location_id;
                    parsedTransactions[index].location_id = payee.most_common_location_id;
                }
                
                // Use the pre-calculated most common project
                if (payee.most_common_project_id) {
                    document.getElementById(`project_${index}`).value = payee.most_common_project_id;
                    parsedTransactions[index].project_id = payee.most_common_project_id;
                }
                
            } catch (error) {
                console.error('Error auto-filling from payee statistics:', error);
            }
        }

        async function detectDuplicatePayees() {
            try {
                const res = await fetch(`${API_URL}/payees/duplicates`);
                if (!res.ok) throw new Error('Failed to detect duplicates');
                const data = await res.json();

                if (!data.groups || data.groups.length === 0) {
                    await customConfirm('No duplicate payees found.', 'Duplicate Detection', 'OK');
                    return;
                }

                for (const group of data.groups) {
                    // The first payee in the group has the most transactions (keep it)
                    const keep = group[0];
                    const duplicates = group.slice(1);

                    for (const dup of duplicates) {
                        const confirmed = await customConfirm(
                            `<b>"${dup.name}"</b> (${dup.transaction_count} transactions) looks like a duplicate of <b>"${keep.name}"</b> (${keep.transaction_count} transactions).\n\nMerge into <b>"${keep.name}"</b>? All transactions will be reassigned.`,
                            'Merge Duplicate Payee',
                            'Merge'
                        );
                        if (!confirmed) continue;

                        const mergeRes = await fetch(`${API_URL}/payees/${keep.id}/merge/${dup.id}`, { method: 'POST' });
                        if (!mergeRes.ok) throw new Error('Failed to merge');
                        const result = await mergeRes.json();
                        keep.transaction_count += result.transactions_reassigned;
                        showSuccess(`Merged "${dup.name}" into "${keep.name}" (${result.transactions_reassigned} transactions reassigned)`);
                    }
                }

                // Refresh payees list
                const payeesRes = await fetch(`${API_URL}/payees`);
                allPayees = await payeesRes.json();
                displayPayees();
            } catch (error) {
                console.error('Error detecting duplicates:', error);
                showError('Error detecting duplicates: ' + error.message);
            }
        }

        // Apply payee suggestion to other transactions with same description
        function applySuggestionToSimilar(sourceIndex) {
            const sourceDescription = parsedTransactions[sourceIndex].description;
            const sourcePayee = document.getElementById(`payee_${sourceIndex}`).value;
            
            if (!sourcePayee || !sourceDescription) return;
            
            // Apply to all other transactions with same description
            parsedTransactions.forEach((trans, index) => {
                if (index !== sourceIndex && trans.description === sourceDescription) {
                    const payeeInput = document.getElementById(`payee_${index}`);
                    const row = payeeInput.closest('tr');
                    
                    // Update the payee value
                    payeeInput.value = sourcePayee;
                    payeeSuggestions[sourceDescription] = sourcePayee;
                    
                    // Add visual feedback
                    row.style.transition = 'background-color 0.3s';
                    row.style.backgroundColor = '#d1f2eb';
                    
                    // Trigger the change handler WITH skipSimilarApplication=true to avoid recursion
                    handlePayeeChange(index, true);
                    
                    // Remove highlight after a short delay
                    setTimeout(() => {
                        row.style.backgroundColor = '';
                    }, 1000);
                }
            });
            // No toast message - visual highlight is enough feedback
        }

        // Handle parent category change
        function handleParentCategoryChange(index) {
            const parentSelect = document.getElementById(`parentCategory_${index}`);
            const parentValue = parentSelect.value;
            const categorySelect = document.getElementById(`category_${index}`);
            
            // Handle "Add new" option
            if (parentValue === '__NEW__') {
                parentSelect.value = '';
                document.getElementById('newParentCategoryForIndex').value = index;
                document.getElementById('newParentCategoryName').value = '';
                openModal('newParentCategoryModal');
                return;
            }
            
            categorySelect.innerHTML = '<option value="">Select category...</option>';
            
            if (!parentValue) {
                categorySelect.disabled = true;
                return;
            }
            
            // Filter categories by parent
            const subcategories = allCategories
                .filter(c => c.parent === parentValue)
                .sort((a, b) => a.name.localeCompare(b.name));
            
            categorySelect.disabled = false;
            subcategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                categorySelect.appendChild(option);
            });
            
            // Add "new subcategory" option
            const newOption = document.createElement('option');
            newOption.value = '__NEW__';
            newOption.textContent = '‚ûï Add new...';
            newOption.style.color = '#667eea';
            newOption.style.fontWeight = 'bold';
            categorySelect.appendChild(newOption);
        }
        
        function handleSubcategoryChange(index) {
            const categorySelect = document.getElementById(`category_${index}`);
            if (categorySelect.value === '__NEW__') {
                categorySelect.value = '';
                const parentValue = document.getElementById(`parentCategory_${index}`).value;
                document.getElementById('newSubcategoryForIndex').value = index;
                document.getElementById('newSubcategoryParentName').value = parentValue;
                document.getElementById('newSubcategoryNameImport').value = '';
                openModal('newSubcategoryModalImport');
            }
        }
        
        function handleLocationChange(index) {
            const locationSelect = document.getElementById(`location_${index}`);
            if (locationSelect.value === '__NEW__') {
                locationSelect.value = '';
                document.getElementById('newLocationForIndex').value = index;
                document.getElementById('newLocationNameImport').value = '';
                openModal('newLocationModalImport');
            }
        }

        async function saveNewParentCategoryForImport() {
            const name = document.getElementById('newParentCategoryName').value.trim();
            const index = document.getElementById('newParentCategoryForIndex').value;
            
            if (!name) { alert('Please enter a category name'); return; }
            
            try {
                const response = await fetch(`${API_URL}/categories`, {
                    method: 'POST',
                    body: JSON.stringify({ name: name, parent: null }),
                    headers: {'Content-Type': 'application/json'}
                });
                const newCategory = await response.json();
                
                // Reload categories
                const catResponse = await fetch(`${API_URL}/categories?limit=1000`);
                allCategories = await catResponse.json();
                
                // Update all parent category selectors
                refreshAllParentCategorySelectors();
                
                // Select the new category in the triggering row
                document.getElementById(`parentCategory_${index}`).value = name;
                handleParentCategoryChange(index);
                
                closeModal('newParentCategoryModal');
                showSuccess(`Created category: ${name}`);
            } catch (error) {
                showError('Failed to create category: ' + error.message);
            }
        }

        async function saveNewSubcategoryForImport() {
            const name = document.getElementById('newSubcategoryNameImport').value.trim();
            const parent = document.getElementById('newSubcategoryParentName').value;
            const index = document.getElementById('newSubcategoryForIndex').value;
            
            if (!name) { alert('Please enter a subcategory name'); return; }
            
            try {
                const response = await fetch(`${API_URL}/categories`, {
                    method: 'POST',
                    body: JSON.stringify({ name: name, parent: parent }),
                    headers: {'Content-Type': 'application/json'}
                });
                const newCategory = await response.json();
                
                // Reload categories
                const catResponse = await fetch(`${API_URL}/categories?limit=1000`);
                allCategories = await catResponse.json();
                
                // Refresh subcategory selector and select new one
                handleParentCategoryChange(index);
                document.getElementById(`category_${index}`).value = newCategory.id;
                
                closeModal('newSubcategoryModalImport');
                showSuccess(`Created subcategory: ${name}`);
            } catch (error) {
                showError('Failed to create subcategory: ' + error.message);
            }
        }

        async function saveNewLocationForImport() {
            const name = document.getElementById('newLocationNameImport').value.trim();
            const index = document.getElementById('newLocationForIndex').value;
            
            if (!name) { alert('Please enter a location name'); return; }
            
            try {
                const response = await fetch(`${API_URL}/locations`, {
                    method: 'POST',
                    body: JSON.stringify({ name: name }),
                    headers: {'Content-Type': 'application/json'}
                });
                const newLocation = await response.json();
                
                // Reload locations
                const locResponse = await fetch(`${API_URL}/locations`);
                allLocations = await locResponse.json();
                
                // Update all location selectors
                refreshAllLocationSelectors();
                
                // Select the new location in the triggering row
                document.getElementById(`location_${index}`).value = newLocation.id;
                
                closeModal('newLocationModalImport');
                showSuccess(`Created location: ${name}`);
            } catch (error) {
                showError('Failed to create location: ' + error.message);
            }
        }

        function refreshAllParentCategorySelectors() {
            const parents = getUniqueParents();
            parsedTransactions.forEach((trans, index) => {
                const select = document.getElementById(`parentCategory_${index}`);
                if (select && !select.disabled) {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Parent...</option>' +
                        parents.map(p => `<option value="${p}">${p}</option>`).join('') +
                        '<option value="__NEW__" style="color:#667eea;font-weight:bold">‚ûï Add new...</option>';
                    select.value = currentValue;
                }
            });
        }

        function refreshAllLocationSelectors() {
            parsedTransactions.forEach((trans, index) => {
                const select = document.getElementById(`location_${index}`);
                if (select && !select.disabled) {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Loc...</option>' +
                        allLocations.map(l => `<option value="${l.id}">${l.name}</option>`).join('') +
                        '<option value="__NEW__" style="color:#667eea;font-weight:bold">‚ûï Add...</option>';
                    select.value = currentValue;
                }
            });
        }


        // Update import counts
        function updateImportCounts() {
            let duplicateCount = 0;
            let newCount = 0;
            let skippedCount = 0;
            
            parsedTransactions.forEach(trans => {
                if (trans.skip) {
                    skippedCount++;
                } else if (trans.isDuplicate) {
                    duplicateCount++;
                } else {
                    newCount++;
                }
            });
            
            document.getElementById('duplicateCount').textContent = duplicateCount;
            document.getElementById('newCount').textContent = newCount;
            document.getElementById('importCount').textContent = newCount;
        }

        // Import transactions
        async function importTransactions() {
            const transactionsToImport = parsedTransactions.filter(t => !t.isDuplicate && !t.skip);
            
            if (transactionsToImport.length === 0) {
                showToast('No new transactions to import', 'error');
                return;
            }
            
            const confirmed = await customConfirm(
                `Import ${transactionsToImport.length} transactions?`,
                'Confirm Import',
                'Import'
            );
            if (!confirmed) return;
            
            // Show loading indicator
            showToast('‚è≥ Importing transactions... please wait', 'success');
            
            // Disable button during import
            const importButton = document.querySelector('button[onclick*="importTransactions"]');
            if (importButton) importButton.disabled = true;

            let successCount = 0;
            let errorCount = 0;
            let createdPayeesCount = 0;
            let transferCount = 0;

            try {
                // ============================================
                // PHASE 1: Create any new payees (still sequential but usually few)
                // ============================================
                const payeesToCreate = new Set();
                const payeeNameToIdMap = {};
                
                // Build map of existing payees
                allPayees.forEach(p => {
                    payeeNameToIdMap[p.name.toLowerCase()] = p.id;
                });
                
                // Find new payees needed
                for (let i = 0; i < parsedTransactions.length; i++) {
                    const trans = parsedTransactions[i];
                    if (trans.isDuplicate || trans.skip) continue;
                    
                    const type = document.getElementById(`type_${i}`).value;
                    if (type === 'transfer') continue;
                    
                    const payeeName = document.getElementById(`payee_${i}`).value.trim();
                    if (payeeName && !payeeNameToIdMap[payeeName.toLowerCase()]) {
                        payeesToCreate.add(payeeName);
                    }
                }
                
                // Create new payees
                for (const payeeName of payeesToCreate) {
                    try {
                        const res = await fetch(`${API_URL}/payees`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ name: payeeName })
                        });
                        if (res.ok) {
                            const newPayee = await res.json();
                            allPayees.push(newPayee);
                            payeeNameToIdMap[payeeName.toLowerCase()] = newPayee.id;
                            createdPayeesCount++;
                        }
                    } catch (err) {
                        console.warn('Could not create payee:', payeeName);
                    }
                }
                
                // ============================================
                // PHASE 2: Process transfers (still sequential - usually few)
                // ============================================
                for (let i = 0; i < parsedTransactions.length; i++) {
                    const trans = parsedTransactions[i];
                    if (trans.isDuplicate || trans.skip) continue;
                    
                    const type = document.getElementById(`type_${i}`).value;
                    if (type !== 'transfer') continue;
                    
                    const destinationAccountId = parseInt(document.getElementById(`account_${i}`).value);
                    if (!destinationAccountId) {
                        errorCount++; continue;
                    }
                    
                    const isOutgoing = trans.amount < 0;
                    const absoluteAmount = Math.abs(trans.amount);
                    const convertedInput = document.getElementById(`convertedAmount_${i}`);
                    let convertedVal = convertedInput ? parseFloat(convertedInput.value) : null;
                    
                    const payload = {
                        date: trans.date,
                        from_account_id: isOutgoing ? trans.account_id : destinationAccountId,
                        to_account_id: isOutgoing ? destinationAccountId : trans.account_id,
                        from_amount: isOutgoing ? absoluteAmount : (convertedVal || absoluteAmount),
                        to_amount: isOutgoing ? (convertedVal || absoluteAmount) : absoluteAmount,
                        note: trans.note
                    };
                    
                    const res = await fetch(`${API_URL}/transactions/transfers`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    if (res.ok) { successCount++; transferCount++; }
                    else errorCount++;
                }
                
                // ============================================
                // PHASE 3: Batch create regular transactions (FAST!)
                // ============================================
                const regularTransactions = [];
                
                for (let i = 0; i < parsedTransactions.length; i++) {
                    const trans = parsedTransactions[i];
                    if (trans.isDuplicate || trans.skip) continue;
                    
                    const type = document.getElementById(`type_${i}`).value;
                    if (type === 'transfer') continue;
                    
                    const payeeName = document.getElementById(`payee_${i}`).value.trim();
                    const payeeId = payeeName ? (payeeNameToIdMap[payeeName.toLowerCase()] || null) : null;
                    
                    const categoryId = document.getElementById(`category_${i}`).value;
                    const locationId = document.getElementById(`location_${i}`).value;
                    const projectId = document.getElementById(`project_${i}`).value;
                    
                    regularTransactions.push({
                        date: trans.date,
                        amount: trans.amount,
                        currency: 'GBP',
                        account_id: trans.account_id,
                        category_id: categoryId ? parseInt(categoryId) : null,
                        payee_id: payeeId,
                        location_id: locationId ? parseInt(locationId) : null,
                        project_id: projectId ? parseInt(projectId) : null,
                        note: trans.note
                    });
                }
                
                // Send batch request if we have regular transactions
                if (regularTransactions.length > 0) {
                    console.log(`Sending batch of ${regularTransactions.length} transactions`);
                    
                    const batchRes = await fetch(`${API_URL}/transactions/batch`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(regularTransactions)
                    });
                    
                    if (batchRes.ok) {
                        const result = await batchRes.json();
                        successCount += result.created;
                        errorCount += result.errors.length;
                        console.log('Batch result:', result);
                    } else {
                        console.error('Batch creation failed');
                        errorCount += regularTransactions.length;
                    }
                }

                // ============================================
                // PHASE 4: Recalculate balances once at the end
                // ============================================
                if (createdPayeesCount > 0) {
                    showToast(`Created ${createdPayeesCount} new payees automatically`, 'success');
                }

                // ALWAYS recalculate balances if we imported any transactions
                if (successCount > 0) {
                    showToast('üîÑ Recalculating all balances...', 'success');
                    
                    try {
                        const recalcRes = await fetch(`${API_URL}/admin/initialise-balances`, {
                            method: 'POST'
                        });
                        
                        if (recalcRes.ok) {
                            if (errorCount === 0) {
                                showToast(`‚úÖ Successfully imported ${successCount} transactions and updated balances!`, 'success');
                            } else {
                                showToast(`‚ö†Ô∏è Imported ${successCount} transactions (${errorCount} failed). Balances updated.`, 'error');
                            }
                            setTimeout(() => {
                                closeModal('importModal');
                                cancelImport();
                            }, 1500);
                        } else {
                            showToast('‚ö†Ô∏è Imported transactions but failed to recalculate balances. Run "Recalculate Balances" manually.', 'error');
                        }
                    } catch (err) {
                        console.error('Balance recalculation error:', err);
                        showToast('‚ö†Ô∏è Error triggering balance recalculation. Run "Recalculate Balances" manually.', 'error');
                    }
                } else if (errorCount > 0) {
                    showToast(`‚ùå Import failed: ${errorCount} errors. Check console for details.`, 'error');
                } else {
                    showToast('‚ö†Ô∏è No transactions were imported.', 'error');
                }

            } catch (e) {
                console.error(e);
                showToast('Critical error during import: ' + e.message, 'error');
            } finally {
                if (importButton) importButton.disabled = false;
            }
        }

        // Parse generic CSV format
        async function parseGenericCSV(lines, headers, accountId) {
            parsedTransactions = [];
            
            // Try to detect common column names
            const dateIdx = headers.findIndex(h => 
                h.toLowerCase().includes('date') || h.toLowerCase().includes('fecha'));
            const descIdx = headers.findIndex(h => 
                h.toLowerCase().includes('description') || h.toLowerCase().includes('concept') || 
                h.toLowerCase().includes('name') || h.toLowerCase().includes('descripci√≥n'));
            const amountIdx = headers.findIndex(h => 
                h.toLowerCase().includes('amount') || h.toLowerCase().includes('importe'));
            
            if (dateIdx === -1 || amountIdx === -1) {
                throw new Error('Could not detect date and amount columns. Please use a supported format.');
            }
            
            // Track time for transactions on same day
            let lastDate = null;
            let timeCounter = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const values = parseCSVLine(line);
                
                if (values.length < headers.length) continue;
                
                const dateStr = values[dateIdx];
                const description = descIdx !== -1 ? values[descIdx] : '';
                const amountStr = values[amountIdx].replace(/[¬£‚Ç¨$,]/g, '');
                const amount = parseFloat(amountStr);
                
                if (!dateStr || isNaN(amount)) continue;
                
                // Parse date and add time
                let date;
                try {
                    date = new Date(dateStr);
                    if (isNaN(date.getTime())) {
                        // Try UK format DD/MM/YYYY
                        const parts = dateStr.split('/');
                        if (parts.length === 3) {
                            date = new Date(`${parts[2]}-${parts[1]}-${parts[0]}`);
                        }
                    }
                } catch (e) {
                    continue;
                }
                
                // Handle time assignment for same day transactions
                const dateOnly = date.toDateString();
                if (dateOnly !== lastDate) {
                    lastDate = dateOnly;
                    timeCounter = 0;
                }
                
                // Set time: 12:00 for first transaction of the day, then increment by minute
                const hours = 12;
                const minutes = timeCounter;
                timeCounter++;
                
                const datetime = new Date(date);
                datetime.setHours(hours, minutes, 0, 0);
                
                parsedTransactions.push({
                    date: datetime.toISOString().slice(0, 19),
                    description: description,
                    amount: amount,
                    note: '',
                    account_id: parseInt(accountId),
                    isDuplicate: false,
                    type: 'transaction',
                    payee_id: null,
                    category_id: null,
                    location_id: null,
                    project_id: null
                });
            }
            
            // Check for duplicates
            await checkDuplicates();
        }

        // Parse Bank of Scotland CSV format
        async function parseBankOfScotlandCSV(lines, headers, accountId) {
            console.log('=== Starting Bank of Scotland CSV Parse ===');
            console.log('Headers:', headers);
            
            parsedTransactions = [];
            
            // Bank of Scotland CSV includes Sort Code and Account Number columns
            // Find indices dynamically to handle column order
            const dateIdx = headers.findIndex(h => h.toLowerCase().includes('transaction date'));
            const typeIdx = headers.findIndex(h => h.toLowerCase().includes('transaction type'));
            const descIdx = headers.findIndex(h => h.toLowerCase().includes('transaction description'));
            const debitIdx = headers.findIndex(h => h.toLowerCase().includes('debit amount'));
            const creditIdx = headers.findIndex(h => h.toLowerCase().includes('credit amount'));
            const balanceIdx = headers.findIndex(h => h.toLowerCase().includes('balance'));
            
            console.log('Column indices found:');
            console.log('  Date:', dateIdx);
            console.log('  Type:', typeIdx);
            console.log('  Description:', descIdx);
            console.log('  Debit:', debitIdx);
            console.log('  Credit:', creditIdx);
            console.log('  Balance:', balanceIdx);
            
            // Validate that we found all required columns
            if (dateIdx === -1 || descIdx === -1 || debitIdx === -1 || creditIdx === -1) {
                const missingColumns = [];
                if (dateIdx === -1) missingColumns.push('Transaction Date');
                if (descIdx === -1) missingColumns.push('Transaction Description');
                if (debitIdx === -1) missingColumns.push('Debit Amount');
                if (creditIdx === -1) missingColumns.push('Credit Amount');
                
                throw new Error('Could not find required columns: ' + missingColumns.join(', ') + 
                            '\n\nFound headers: ' + headers.join(', '));
            }
            
            // Track time for transactions on same day
            let lastDate = null;
            let timeCounter = 0;
            let successCount = 0;
            let skipCount = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) {
                    skipCount++;
                    continue;
                }
                
                try {
                    const values = parseCSVLine(line);
                    
                    // Log first transaction for debugging
                    if (i === 1) {
                        console.log('First data line values:', values);
                    }
                    
                    // Skip if we don't have enough values
                    const maxIdx = Math.max(dateIdx, typeIdx, descIdx, debitIdx, creditIdx, balanceIdx);
                    if (values.length <= maxIdx) {
                        console.warn(`Line ${i}: Not enough values (${values.length} vs required ${maxIdx + 1})`);
                        skipCount++;
                        continue;
                    }
                    
                    const dateStr = values[dateIdx];
                    const type = typeIdx !== -1 ? values[typeIdx] : '';
                    const description = values[descIdx];
                    
                    // Parse debit and credit amounts, removing any quotes
                    const debitStr = values[debitIdx].replace(/['"]/g, '').trim();
                    const creditStr = values[creditIdx].replace(/['"]/g, '').trim();
                    
                    const debit = debitStr ? parseFloat(debitStr) : 0;
                    const credit = creditStr ? parseFloat(creditStr) : 0;
                    
                    if (!dateStr) {
                        skipCount++;
                        continue;
                    }
                    
                    // Calculate amount (credit is positive, debit is negative)
                    const amount = credit > 0 ? credit : -debit;
                    
                    if (amount === 0) {
                        skipCount++;
                        continue;
                    }
                    
                    // Parse date (format: DD/MM/YYYY)
                    let date;
                    const dateParts = dateStr.split('/');
                    if (dateParts.length === 3) {
                        const day = dateParts[0].padStart(2, '0');
                        const month = dateParts[1].padStart(2, '0');
                        const year = dateParts[2];
                        
                        date = new Date(`${year}-${month}-${day}`);
                        
                        if (isNaN(date.getTime())) {
                            throw new Error(`Invalid date: ${dateStr}`);
                        }
                    } else {
                        throw new Error(`Invalid date format: ${dateStr} (expected DD/MM/YYYY)`);
                    }
                    
                    // Handle time assignment
                    const dateOnly = date.toDateString();
                    if (dateOnly !== lastDate) {
                        lastDate = dateOnly;
                        timeCounter = 0;
                    }
                    
                    const hours = 12;
                    const minutes = timeCounter;
                    timeCounter--;
                    
                    const datetime = new Date(date);
                    datetime.setHours(hours, minutes, 0, 0);
                    
                    // Combine type and description for better context
                    const fullDescription = type && description ? `${type} - ${description}` : (description || type || '');
                    
                    parsedTransactions.push({
                        date: datetime.toISOString().slice(0, 19),
                        description: fullDescription,
                        amount: amount,
                        note: '',
                        account_id: parseInt(accountId),
                        isDuplicate: false,
                        type: 'transaction',
                        payee_id: null,
                        category_id: null,
                        location_id: null,
                        project_id: null
                    });
                    
                    successCount++;
                    
                } catch (error) {
                    console.error(`Error parsing line ${i}:`, error.message);
                    console.error('Line content:', line);
                    // Continue processing other lines instead of failing completely
                    skipCount++;
                }
            }
            
            console.log(`Parse complete: ${successCount} successful, ${skipCount} skipped`);
            
            await checkDuplicates();
            
            if (parsedTransactions.length === 0) {
                throw new Error('No transactions found in CSV. Please check the file format.\n\n' +
                            `Processed ${lines.length - 1} lines, but none were valid transactions.`);
            }
            
            console.log('=== Bank of Scotland CSV Parse Complete ===');
        }

        // Parse PayPal CSV format
        async function parsePayPalCSV(lines, headers, accountId) {
            console.log('=== Starting PayPal CSV Parse ===');
            console.log('Headers:', headers);
            
            parsedTransactions = [];
            
            // Find column indices
            const dateIdx = headers.findIndex(h => h.toLowerCase() === 'date');
            const timeIdx = headers.findIndex(h => h.toLowerCase() === 'time');
            const descriptionIdx = headers.findIndex(h => h.toLowerCase() === 'description');
            const currencyIdx = headers.findIndex(h => h.toLowerCase() === 'currency');
            const grossIdx = headers.findIndex(h => h.toLowerCase() === 'gross');
            const feeIdx = headers.findIndex(h => h.toLowerCase() === 'fee');
            const netIdx = headers.findIndex(h => h.toLowerCase() === 'net');
            const nameIdx = headers.findIndex(h => h.toLowerCase() === 'name');
            const invoiceIdx = headers.findIndex(h => h.toLowerCase() === 'invoice id');
            
            console.log('Column indices found:');
            console.log('  Date:', dateIdx);
            console.log('  Time:', timeIdx);
            console.log('  Description:', descriptionIdx);
            console.log('  Currency:', currencyIdx);
            console.log('  Gross:', grossIdx);
            console.log('  Fee:', feeIdx);
            console.log('  Net:', netIdx);
            console.log('  Name:', nameIdx);
            console.log('  Invoice:', invoiceIdx);
            
            // Validate required columns
            if (dateIdx === -1 || timeIdx === -1 || grossIdx === -1 || descriptionIdx === -1) {
                const missingColumns = [];
                if (dateIdx === -1) missingColumns.push('Date');
                if (timeIdx === -1) missingColumns.push('Time');
                if (grossIdx === -1) missingColumns.push('Gross');
                if (descriptionIdx === -1) missingColumns.push('Description');
                
                throw new Error('Could not find required PayPal columns: ' + missingColumns.join(', ') + 
                            '\n\nFound headers: ' + headers.join(', '));
            }
            
            let successCount = 0;
            let skipCount = 0;
            
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) {
                    skipCount++;
                    continue;
                }
                
                try {
                    const values = parseCSVLine(line);
                    
                    // Log first transaction for debugging
                    if (i === 1) {
                        console.log('First data line values:', values);
                    }
                    
                    const maxIdx = Math.max(dateIdx, timeIdx, descriptionIdx, grossIdx, nameIdx, invoiceIdx);
                    if (values.length <= maxIdx) {
                        console.warn(`Line ${i}: Not enough values (${values.length} vs required ${maxIdx + 1})`);
                        skipCount++;
                        continue;
                    }
                    
                    const dateStr = values[dateIdx].replace(/"/g, '');
                    const timeStr = values[timeIdx].replace(/"/g, '');
                    const description = values[descriptionIdx].replace(/"/g, '');
                    const grossStr = values[grossIdx].replace(/"/g, '').trim();
                    const feeStr = feeIdx !== -1 ? values[feeIdx].replace(/"/g, '').trim() : '0.00';
                    const merchantName = nameIdx !== -1 ? values[nameIdx].replace(/"/g, '').trim() : '';
                    const invoiceId = invoiceIdx !== -1 ? values[invoiceIdx].replace(/"/g, '').trim() : '';
                    
                    // Skip "BML Credit" entries as they're just funding transactions
                    if (description.includes('BML Credit') || description.includes('Transfer from BML')) {
                        skipCount++;
                        continue;
                    }
                    
                    if (!dateStr || !grossStr) {
                        skipCount++;
                        continue;
                    }
                    
                    const gross = parseFloat(grossStr);
                    const fee = parseFloat(feeStr);
                    
                    if (isNaN(gross)) {
                        skipCount++;
                        continue;
                    }
                    
                    // Parse date (format: DD/MM/YYYY)
                    let date;
                    const dateParts = dateStr.split('/');
                    if (dateParts.length === 3) {
                        const day = dateParts[0].padStart(2, '0');
                        const month = dateParts[1].padStart(2, '0');
                        const year = dateParts[2];
                        
                        // Parse time (format: HH:MM:SS)
                        const time = timeStr || '12:00:00';
                        
                        // Create ISO format datetime
                        const datetime = `${year}-${month}-${day}T${time}`;
                        
                        // Build description combining merchant name and transaction type
                        let fullDescription = '';
                        if (merchantName) {
                            fullDescription = merchantName;
                            if (description && !description.includes('Express Checkout')) {
                                fullDescription += ` (${description})`;
                            }
                        } else {
                            fullDescription = description;
                        }
                        
                        // Build note with additional info
                        let note = '';
                        if (invoiceId) {
                            note = `Invoice: ${invoiceId}`;
                        }
                        if (fee !== 0) {
                            note += (note ? ' | ' : '') + `Fee: ¬£${fee.toFixed(2)}`;
                        }
                        
                        parsedTransactions.push({
                            date: datetime,
                            description: fullDescription,
                            amount: gross,
                            note: note,
                            account_id: parseInt(accountId),
                            isDuplicate: false,
                            type: 'transaction',
                            payee_id: null,
                            category_id: null,
                            location_id: null,
                            project_id: null
                        });
                        
                        successCount++;
                    } else {
                        throw new Error(`Invalid date format: ${dateStr} (expected DD/MM/YYYY)`);
                    }
                    
                } catch (error) {
                    console.error(`Error parsing line ${i}:`, error.message);
                    console.error('Line content:', line);
                    skipCount++;
                }
            }
            
            console.log(`Parse complete: ${successCount} successful, ${skipCount} skipped`);
            
            await checkDuplicates();
            
            if (parsedTransactions.length === 0) {
                throw new Error('No transactions found in CSV. Please check the file format.\n\n' +
                            `Processed ${lines.length - 1} lines, but none were valid transactions.`);
            }
            
            console.log('=== PayPal CSV Parse Complete ===');
        }

        // Load data for export
        async function loadExportData() {
            try {
                // Load accounts for filter
                const accountsResponse = await fetch(`${API_URL}/accounts`);
                const accounts = await accountsResponse.json();
                
                const exportAccountSelect = document.getElementById('exportAccount');
                exportAccountSelect.innerHTML = '<option value="">All accounts</option>';
                accounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    exportAccountSelect.appendChild(option);
                });
                
                // Load categories for filter
                await loadCategories();
                
                const exportParentSelect = document.getElementById('exportParentCategory');
                exportParentSelect.innerHTML = '<option value="">All categories</option>';
                
                const parents = [...new Set(allCategories
                    .map(c => c.parent)
                    .filter(p => p && p.trim() !== ''))]
                    .sort();
                
                parents.forEach(parent => {
                    const option = document.createElement('option');
                    option.value = parent;
                    option.textContent = parent;
                    exportParentSelect.appendChild(option);
                });
                
            } catch (error) {
                console.error('Error loading export data:', error);
                showError('Failed to load export options');
            }
        }

        // Load subcategories for export
        function loadExportSubcategories() {
            const parentValue = document.getElementById('exportParentCategory').value;
            const categorySelect = document.getElementById('exportCategory');
            
            categorySelect.innerHTML = '<option value="">All subcategories</option>';
            
            if (!parentValue) {
                categorySelect.disabled = true;
                return;
            }
            
            const subcategories = allCategories
                .filter(c => c.parent === parentValue)
                .sort((a, b) => a.name.localeCompare(b.name));
            
            if (subcategories.length === 0) {
                categorySelect.disabled = true;
                return;
            }
            
            categorySelect.disabled = false;
            subcategories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat.id;
                option.textContent = cat.name;
                categorySelect.appendChild(option);
            });
        }

        // Export to CSV
        async function exportToCSV() {
            try {
                // Get filter values
                const startDate = document.getElementById('exportStartDate').value;
                const endDate = document.getElementById('exportEndDate').value;
                const accountId = document.getElementById('exportAccount').value;
                const categoryId = document.getElementById('exportCategory').value;
                const format = document.getElementById('exportFormat').value;
                
                // Build query parameters
                // Use a reasonable default limit, but allow larger exports if filters are specified
                let url = `${API_URL}/transactions?`;
                
                // If specific filters are provided, use higher limit; otherwise use reasonable default
                const hasFilters = startDate || endDate || accountId || categoryId;
                const limit = hasFilters ? 50000 : 10000;
                url += `limit=${limit}`;
                
                if (startDate) {
                    url += `&start_date=${startDate}`;
                }
                if (endDate) {
                    url += `&end_date=${endDate}`;
                }
                if (accountId) {
                    url += `&account_id=${accountId}`;
                }
                if (categoryId) {
                    url += `&category_id=${categoryId}`;
                }
                
                // Fetch transactions
                const response = await fetch(url);
                const transactions = await response.json();
                
                if (transactions.length === 0) {
                    showError('No transactions found with selected filters');
                    return;
                }
                
                // Generate CSV content
                let csvContent = '';
                
                if (format === 'standard') {
                    // Standard format: Date, Description, Amount, Category, Account
                    csvContent = 'Date,Time,Description,Amount,Currency,Category,Account,Payee,Location,Project,Note\n';
                    
                    transactions.forEach(t => {
                        const date = new Date(t.date);
                        const dateStr = date.toLocaleDateString('en-GB');
                        const timeStr = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                        const description = (t.payee_name || 'No payee').replace(/,/g, ';');
                        const amount = t.amount.toFixed(2);
                        const category = (t.category_name || 'Uncategorised').replace(/,/g, ';');
                        const account = (t.account_name || '').replace(/,/g, ';');
                        const payee = (t.payee_name || '').replace(/,/g, ';');
                        const location = (t.location_name || '').replace(/,/g, ';');
                        const project = (t.project_name || '').replace(/,/g, ';');
                        const note = (t.note || '').replace(/,/g, ';');
                        
                        csvContent += `${dateStr},${timeStr},"${description}",${amount},${t.currency},"${category}","${account}","${payee}","${location}","${project}","${note}"\n`;
                    });
                } else {
                    // Detailed format: All fields including IDs
                    csvContent = 'ID,Date,Time,Amount,Currency,Account ID,Account Name,Category ID,Category Name,Payee ID,Payee Name,Location ID,Location Name,Project ID,Project Name,Note,Created At,Updated At\n';
                    
                    transactions.forEach(t => {
                        const date = new Date(t.date);
                        const dateStr = date.toLocaleDateString('en-GB');
                        const timeStr = date.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit' });
                        const amount = t.amount.toFixed(2);
                        const note = (t.note || '').replace(/,/g, ';').replace(/"/g, '""');
                        const accountName = (t.account_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const categoryName = (t.category_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const payeeName = (t.payee_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const locationName = (t.location_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        const projectName = (t.project_name || '').replace(/,/g, ';').replace(/"/g, '""');
                        
                        csvContent += `${t.id},${dateStr},${timeStr},${amount},${t.currency},`;
                        csvContent += `${t.account_id || ''},"${accountName}",`;
                        csvContent += `${t.category_id || ''},"${categoryName}",`;
                        csvContent += `${t.payee_id || ''},"${payeeName}",`;
                        csvContent += `${t.location_id || ''},"${locationName}",`;
                        csvContent += `${t.project_id || ''},"${projectName}",`;
                        csvContent += `"${note}","${t.created_at || ''}","${t.updated_at || ''}"\n`;
                    });
                }
                
                // Create download link
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                const downloadUrl = URL.createObjectURL(blob);

                // Generate filename with date
                const now = new Date();
                const filename = `financisto_export_${now.getFullYear()}-${(now.getMonth()+1).toString().padStart(2,'0')}-${now.getDate().toString().padStart(2,'0')}.csv`;

                link.setAttribute('href', downloadUrl);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);

                showSuccess(`Exported ${transactions.length} transactions successfully!`);
                closeModal('exportModal');

                } catch (error) {
                    console.error('Error exporting to CSV:', error);
                    showError('Error exporting data: ' + error.message);
                }
        }

        // Download database backup
        async function downloadDatabaseBackup() {
            const statusDiv = document.getElementById('backupStatus');
            
            try {
                statusDiv.style.display = 'block';
                statusDiv.style.background = '#e3f2fd';
                statusDiv.style.color = '#1976d2';
                statusDiv.innerHTML = '‚è≥ Creating backup...';
                
                // Call the backup endpoint
                const response = await fetch(`${API_URL}/admin/backup-database`, {
                    method: 'POST'
                });
                
                if (!response.ok) {
                    throw new Error('Failed to create backup');
                }
                
                // Get the blob from response
                const blob = await response.blob();
                
                // Generate filename with timestamp
                const now = new Date();
                const timestamp = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}-${String(now.getDate()).padStart(2, '0')}_${String(now.getHours()).padStart(2, '0')}-${String(now.getMinutes()).padStart(2, '0')}-${String(now.getSeconds()).padStart(2, '0')}`;
                const filename = `delfin_backup_${timestamp}.db`;
                
                // Create download link
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
                
                // Show success message
                statusDiv.style.background = '#d1f2eb';
                statusDiv.style.color = '#0f5132';
                statusDiv.innerHTML = `‚úÖ Backup downloaded successfully!<br><small>${filename}</small>`;
                
                showSuccess(`Database backup downloaded: ${filename}`);
                
                // Close modal after 2 seconds
                setTimeout(() => {
                    closeModal('backupModal');
                }, 2000);
                
            } catch (error) {
                console.error('Error creating backup:', error);
                statusDiv.style.background = '#f8d7da';
                statusDiv.style.color = '#842029';
                statusDiv.innerHTML = '‚ùå Failed to create backup. Please try again.';
                showError('Failed to create backup: ' + error.message);
            }
        }
    </script>
</body>
</html>